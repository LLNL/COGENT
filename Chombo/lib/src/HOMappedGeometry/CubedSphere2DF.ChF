C      _______              __
C     / ___/ /  ___  __ _  / /  ___
C    / /__/ _ \/ _ \/  V \/ _ \/ _ \
C    \___/_//_/\___/_/_/_/_.__/\___/
C    Please refer to Copyright.txt, in Chombo's root directory.

#include "REAL.H"
#include "CONSTANTS.H"

      real_t function rmappedtoreal(rmap)
      implicit none
      real_t rmap
#include "CubedSphereCommon.fh"
!     rratio = rmax / rmin
      rmappedtoreal = rmin * (rratio**(rfac*rmap))

      return
      end


      real_t function rrealtomapped(rreal)
      implicit none
      real_t rreal
#include "CubedSphereCommon.fh"
!     lograt = log(rmax/rmin)
      rrealtomapped = log(rreal/rmin) / (lograt * rfac)

      return
      end


      real_t function derivrmappedtoreal(rmap)
      implicit none
      real_t rmap
      real_t rmappedtoreal
#include "CubedSphereCommon.fh"

      derivrmappedtoreal = rfac * lograt * rmappedtoreal(rmap)

      return
      end

      subroutine subrmappedtoreal(
     $     CHF_REAL[rmappedtorealout],
     $     CHF_CONST_REAL[rmap])

      real_t rmappedtoreal

      rmappedtorealout = rmappedtoreal(rmap)

      return
      end

      subroutine subderivrmappedtoreal(
     $     CHF_REAL[derivmappedtorealout],
     $     CHF_CONST_REAL[rmap])

      real_t derivrmappedtoreal

      derivmappedtorealout = derivrmappedtoreal(rmap)

      return
      end

      subroutine subrrealtomapped(
     $     CHF_REAL[rrealtomappedout],
     $     CHF_CONST_REAL[rreal])

      real_t rrealtomapped

      rrealtomappedout = rrealtomapped(rreal)

      return
      end

      subroutine cubedsphere2dmappedtoreal(
!
!     => inputs,  <= outputs
!     coords <= real coordinates, in physical space
!     xi     => mapped coordinates
!     panel  => panel number
!     bx     => box
!     dx     => mesh spacing
!     base   => base of panel
     &     CHF_FRA[coords],
     &     CHF_CONST_FRA[xi],
     &     CHF_CONST_INT[panel],
     &     CHF_BOX[bx],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_INTVECT[base])
#if CH_SPACEDIM >= 2
      integer CHF_AUTODECL[i]
      real_t dGX, dGY, dInvDelta
#if CH_SPACEDIM == 3
      real_t rreal, rmappedtoreal
      integer dir
#endif
      if (panel .eq. 0) then
         CHF_AUTOMULTIDO[bx; i]
         dGX = tan(xi(CHF_AUTOIX[i], 0) - fourth*Pi)
         dGY = tan(xi(CHF_AUTOIX[i], 1) - fourth*Pi)
         dInvDelta = one / sqrt(one + dGX*dGX + dGY*dGY)
         coords(CHF_AUTOIX[i], 0) = dInvDelta
         coords(CHF_AUTOIX[i], 1) = dGX * dInvDelta
         coords(CHF_AUTOIX[i], 2) = dGY * dInvDelta
         CHF_ENDDO
      elseif (panel .eq. 1) then
         CHF_AUTOMULTIDO[bx; i]
         dGX = tan(xi(CHF_AUTOIX[i], 0) - fourth*Pi)
         dGY = tan(xi(CHF_AUTOIX[i], 1) - fourth*Pi)
         dInvDelta = one / sqrt(one + dGX*dGX + dGY*dGY)
         coords(CHF_AUTOIX[i], 0) = - dGX * dInvDelta
         coords(CHF_AUTOIX[i], 1) = dInvDelta
         coords(CHF_AUTOIX[i], 2) = dGY * dInvDelta
         CHF_ENDDO
      elseif (panel .eq. 2) then
         CHF_AUTOMULTIDO[bx; i]
         dGX = tan(xi(CHF_AUTOIX[i], 0) - fourth*Pi)
         dGY = tan(xi(CHF_AUTOIX[i], 1) - fourth*Pi)
         dInvDelta = one / sqrt(one + dGX*dGX + dGY*dGY)
         coords(CHF_AUTOIX[i], 0) = - dInvDelta
         coords(CHF_AUTOIX[i], 1) = - dGX * dInvDelta
         coords(CHF_AUTOIX[i], 2) = dGY * dInvDelta
         CHF_ENDDO
      elseif (panel .eq. 3) then
         CHF_AUTOMULTIDO[bx; i]
         dGX = tan(xi(CHF_AUTOIX[i], 0) - fourth*Pi)
         dGY = tan(xi(CHF_AUTOIX[i], 1) - fourth*Pi)
         dInvDelta = one / sqrt(one + dGX*dGX + dGY*dGY)
         coords(CHF_AUTOIX[i], 0) = dGX * dInvDelta
         coords(CHF_AUTOIX[i], 1) = - dInvDelta
         coords(CHF_AUTOIX[i], 2) = dGY * dInvDelta
         CHF_ENDDO
      elseif (panel .eq. 4) then
         CHF_AUTOMULTIDO[bx; i]
         dGX = tan(xi(CHF_AUTOIX[i], 0) - fourth*Pi)
         dGY = tan(xi(CHF_AUTOIX[i], 1) - fourth*Pi)
         dInvDelta = one / sqrt(one + dGX*dGX + dGY*dGY)
         coords(CHF_AUTOIX[i], 0) = - dGY * dInvDelta
         coords(CHF_AUTOIX[i], 1) = dGX * dInvDelta
         coords(CHF_AUTOIX[i], 2) = dInvDelta
         CHF_ENDDO
      elseif (panel .eq. 5) then
         CHF_AUTOMULTIDO[bx; i]
         dGX = tan(xi(CHF_AUTOIX[i], 0) - fourth*Pi)
         dGY = tan(xi(CHF_AUTOIX[i], 1) - fourth*Pi)
         dInvDelta = one / sqrt(one + dGX*dGX + dGY*dGY)
         coords(CHF_AUTOIX[i], 0) = dGY * dInvDelta
         coords(CHF_AUTOIX[i], 1) = dGX * dInvDelta
         coords(CHF_AUTOIX[i], 2) = - dInvDelta
         CHF_ENDDO
      else
         print *, 'Error: invalid panel ', panel
         call MAYDAY_ERROR()
      endif
#if CH_SPACEDIM == 3
      CHF_AUTOMULTIDO[bx; i]
         rreal = rmappedtoreal(xi(CHF_AUTOIX[i], 2))
         do dir = 0, CH_SPACEDIM-1
            coords(CHF_AUTOIX[i], dir) = rreal *
     &           coords(CHF_AUTOIX[i], dir)
         enddo
      CHF_ENDDO
#endif
#endif

      return
      end


      subroutine cubedsphere2dnodereal(
!
!     => inputs,  <= outputs
!     coords <= real coordinates, in physical space, of nodes
!     panel  => panel number
!     bx     => box
!     dx     => mesh spacing
!     base   => base of panel
     &     CHF_FRA[coords],
     &     CHF_CONST_INT[panel],
     &     CHF_BOX[bx],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_INTVECT[base])

#if CH_SPACEDIM >= 2
      integer CHF_AUTODECL[i]
      real_t X, Y, dGX, dGY, dInvDelta
#if CH_SPACEDIM == 3
      real_t rmap, rreal, rmappedtoreal
      integer dir
#endif
      CHF_AUTOMULTIDO[bx; i]
         X = (i0 - base(0))* dx(0)
         Y = (i1 - base(1))* dx(1)
         dGX = tan(X - fourth*Pi)
         dGY = tan(Y - fourth*Pi)
         dInvDelta = one / sqrt(one + dGX*dGX + dGY*dGY)
         if (panel .eq. 0) then
            coords(CHF_AUTOIX[i], 0) = dInvDelta
            coords(CHF_AUTOIX[i], 1) = dGX * dInvDelta
            coords(CHF_AUTOIX[i], 2) = dGY * dInvDelta
         elseif (panel .eq. 1) then
            coords(CHF_AUTOIX[i], 0) = - dGX * dInvDelta
            coords(CHF_AUTOIX[i], 1) = dInvDelta
            coords(CHF_AUTOIX[i], 2) = dGY * dInvDelta
         elseif (panel .eq. 2) then
            coords(CHF_AUTOIX[i], 0) = - dInvDelta
            coords(CHF_AUTOIX[i], 1) = - dGX * dInvDelta
            coords(CHF_AUTOIX[i], 2) = dGY * dInvDelta
         elseif (panel .eq. 3) then
            coords(CHF_AUTOIX[i], 0) = dGX * dInvDelta
            coords(CHF_AUTOIX[i], 1) = - dInvDelta
            coords(CHF_AUTOIX[i], 2) = dGY * dInvDelta
         elseif (panel .eq. 4) then
            coords(CHF_AUTOIX[i], 0) = - dGY * dInvDelta
            coords(CHF_AUTOIX[i], 1) = dGX * dInvDelta
            coords(CHF_AUTOIX[i], 2) = dInvDelta
         elseif (panel .eq. 5) then
            coords(CHF_AUTOIX[i], 0) = dGY * dInvDelta
            coords(CHF_AUTOIX[i], 1) = dGX * dInvDelta
            coords(CHF_AUTOIX[i], 2) = - dInvDelta
         else
            print *, 'Error: invalid panel ', panel
            call MAYDAY_ERROR()
         endif
      CHF_ENDDO
#if CH_SPACEDIM == 3
      CHF_AUTOMULTIDO[bx; i]
         rmap = (i2 - base(2))* dx(2)
         rreal = rmappedtoreal(rmap)
         do dir = 0, CH_SPACEDIM-1
            coords(CHF_AUTOIX[i], dir) = rreal *
     &           coords(CHF_AUTOIX[i], dir)
         enddo
      CHF_ENDDO
#endif
#endif

      return
      end


      subroutine cubedsphere2dcellmapped(
!
!     => inputs,  <= outputs
!     coords <= mapped coordinates of cell centers
!     panel  => panel number
!     bx     => box
!     dx     => mesh spacing
!     base   => base of panel
     &     CHF_FRA[coords],
     &     CHF_CONST_INT[panel],
     &     CHF_BOX[bx],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_INTVECT[base])
#if CH_SPACEDIM >= 2
      integer CHF_AUTODECL[i]
      real_t X, Y
#if CH_SPACEDIM == 3
      real_t rmap
#endif
      CHF_AUTOMULTIDO[bx; i]
         X = (i0 - base(0)) * dx(0) + half * dx(0)
         Y = (i1 - base(1)) * dx(1) + half * dx(1)
         coords(CHF_AUTOIX[i], 0) = X + panel*Pi
         coords(CHF_AUTOIX[i], 1) = Y
      CHF_ENDDO
#if CH_SPACEDIM == 3
      CHF_AUTOMULTIDO[bx; i]
         rmap = (i2 - base(2)) * dx(2) + half * dx(2)
         coords(CHF_AUTOIX[i], 2) = rmap
      CHF_ENDDO
#endif
#endif

      return
      end


      subroutine cubedsphere2dnodemapped(
!
!     => inputs,  <= outputs
!     coords <= mapped coordinates of nodes
!     panel  => panel number
!     bx     => box
!     dx     => mesh spacing
!     base   => base of panel
     &     CHF_FRA[coords],
     &     CHF_CONST_INT[panel],
     &     CHF_BOX[bx],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_INTVECT[base])

      integer CHF_AUTODECL[i]
      CHF_AUTOMULTIDO[bx; i]
         CHF_DTERM[
         coords(CHF_AUTOIX[i], 0) = (i0 - base(0)) * dx(0) + panel*Pi ;
         coords(CHF_AUTOIX[i], 1) = (i1 - base(1)) * dx(1) ;
         coords(CHF_AUTOIX[i], 2) = (i2 - base(2)) * dx(2) ;
         coords(CHF_AUTOIX[i], 3) = (i3 - base(3)) * dx(3) ;
         coords(CHF_AUTOIX[i], 4) = (i4 - base(4)) * dx(4) ;
         coords(CHF_AUTOIX[i], 5) = (i5 - base(5)) * dx(5) ]
      CHF_ENDDO

      return
      end


      subroutine cubedsphere2dfacemapped(
!
!     => inputs,  <= outputs
!     coords <= mapped coordinates of face centers
!     panel  => panel number
!     bx     => box
!     dx     => mesh spacing
!     dir    => face direction
!     base   => base of panel
     &     CHF_FRA[coords],
     &     CHF_CONST_INT[panel],
     &     CHF_BOX[bx],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_INTVECT[base])

      integer CHF_AUTODECL[i]
      real_t CHF_AUTODECL[sh]

      CHF_DTERM[
      sh0 = half * dx(0) + panel*Pi ;
      sh1 = half * dx(1) ;
      sh2 = half * dx(2) ;
      sh3 = half * dx(3) ;
      sh4 = half * dx(4) ;
      sh5 = half * dx(5) ]

      CHF_DTERM[
      if (dir .eq. 0) then
         sh0 = panel * Pi ;
      elseif (dir .eq. 1) then
         sh1 = zero ;
      elseif (dir .eq. 2) then
         sh2 = zero ;
      elseif (dir .eq. 3) then
         sh3 = zero ;
      elseif (dir .eq. 4) then
         sh4 = zero ;
      elseif (dir .eq. 5) then
         sh5 = zero ]
      endif

      CHF_AUTOMULTIDO[bx; i]
         CHF_DTERM[
         coords(CHF_AUTOIX[i], 0) = (i0 - base(0)) * dx(0) + sh0 ;
         coords(CHF_AUTOIX[i], 1) = (i1 - base(1)) * dx(1) + sh1 ;
         coords(CHF_AUTOIX[i], 2) = (i2 - base(2)) * dx(2) + sh2 ;
         coords(CHF_AUTOIX[i], 3) = (i3 - base(3)) * dx(3) + sh3 ;
         coords(CHF_AUTOIX[i], 4) = (i4 - base(4)) * dx(4) + sh4 ;
         coords(CHF_AUTOIX[i], 5) = (i5 - base(5)) * dx(5) + sh5 ]
      CHF_ENDDO

      return
      end


      subroutine cubedsphere2dcellvol(
!
!     => inputs,  <= outputs
!     vol    <= cell volumes
!     panel  => panel number
!     bx     => box
!     dx     => mesh spacing
!     base   => base of panel
     &     CHF_FRA1[vol],
     &     CHF_CONST_INT[panel],
     &     CHF_BOX[bx],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_INTVECT[base])

#if CH_SPACEDIM >= 2
      integer CHF_AUTODECL[i]
      real_t Xlo, Ylo, Xhi, Yhi
      real_t Xlo2, Ylo2, Xhi2, Yhi2
#if CH_SPACEDIM == 3
      real_t rholo, rhohi, rlo, rhi
      real_t rmappedtoreal
#endif
      CHF_AUTOMULTIDO[bx; i]
         Xlo = (i0 - base(0)) * dx(0) - fourth*Pi
         Ylo = (i1 - base(1)) * dx(1) - fourth*Pi
         Xhi = Xlo + dx(0)
         Yhi = Ylo + dx(1)
         Xlo = tan(Xlo)
         Ylo = tan(Ylo)
         Xhi = tan(Xhi)
         Yhi = tan(Yhi)
         Xlo2 = Xlo * Xlo
         Ylo2 = Ylo * Ylo
         Xhi2 = Xhi * Xhi
         Yhi2 = Yhi * Yhi
         vol(CHF_AUTOIX[i]) =
     &        atan(Xhi * Yhi / sqrt(one + Xhi2 + Yhi2))
     &        - atan(Xlo * Yhi / sqrt(one + Xlo2 + Yhi2))
     &        - atan(Xhi * Ylo / sqrt(one + Xhi2 + Ylo2))
     &        + atan(Xlo * Ylo / sqrt(one + Xlo2 + Ylo2))
#if CH_SPACEDIM == 3
         rholo = (i2 - base(2)) * dx(2)
         rhohi = rholo + dx(2)
         rlo = rmappedtoreal(rholo)
         rhi = rmappedtoreal(rhohi)
         vol(CHF_AUTOIX[i]) = vol(CHF_AUTOIX[i]) * (rhi - rlo)
#endif
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2dnormal(
!
!     => inputs,  <= outputs
!     normal <= normal vector
!     panel  => panel number
!     bx     => box
!     dir    => direction of normal
!     dx     => mesh spacing
!     base   => base of panel
     &     CHF_FRA[normal],
     &     CHF_CONST_INT[panel],
     &     CHF_BOX[bx],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_INTVECT[base])

!     FIXME for 3D
#if CH_SPACEDIM == 2
      integer CHF_AUTODECL[i]
      real_t Xnode, Ynode, Xlo, Ylo, Xhi, Yhi, denlo, denhi
      CHF_AUTOMULTIDO[bx; i]
         Xnode = (i0 - base(0)) * dx(0) - fourth * Pi
         Ynode = (i1 - base(1)) * dx(1) - fourth * Pi
         Xlo = Xnode
         Xhi = Xnode
         Ylo = Ynode
         Yhi = Ynode
         if (dir .eq. 0) then
            Yhi = Yhi + dx(1)
         elseif (dir .eq. 1) then
            Xhi = Xhi + dx(0)
         endif
         Xlo = tan( Xlo )
         Xhi = tan( Xhi )
         Ylo = tan( Ylo )
         Yhi = tan( Yhi )
         denlo = sqrt(one + Xlo*Xlo + Ylo*Ylo)
         denhi = sqrt(one + Xhi*Xhi + Yhi*Yhi)
         if (dir .eq. 0) then
            normal(CHF_AUTOIX[i], 0) = Yhi/denhi - Ylo/denlo
            normal(CHF_AUTOIX[i], 3) = zero
         elseif (dir .eq. 1) then
            normal(CHF_AUTOIX[i], 0) = zero
            normal(CHF_AUTOIX[i], 3) = Xhi/denhi - Xlo/denlo
         endif
         normal(CHF_AUTOIX[i], 1) = zero
         normal(CHF_AUTOIX[i], 2) = zero
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2davgjinv(
!
!     => inputs,  <= outputs
!     avjinv <= average of 1/J on faces
!     panel  => panel number
!     bx     => box
!     dir    => direction of faces
!     dx     => mesh spacing
!     base   => base of panel
     &     CHF_FRA1[avjinv],
     &     CHF_CONST_INT[panel],
     &     CHF_BOX[bx],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_INTVECT[base])

!     FIXME: note this is on a face!
#if CH_SPACEDIM == 2
      integer CHF_AUTODECL[i]
      real_t foffX, foffY, X, Y, X2, Y2, delta, aji, fac0, fac1
#if CH_SPACEDIM == 3
      real_t rho
#endif

!     Why is foffX or foffY only half dx, not full dx?
      if (dir .eq. 0) then
         foffX = zero
         foffY = half * dx(1)
      elseif (dir .eq. 1) then
         foffX = half * dx(0)
         foffY = zero
      endif
      fac0 = (dx(0)*dx(0)) / (twenty + four)
      fac1 = (dx(1)*dx(1)) / (twenty + four)
      CHF_AUTOMULTIDO[bx; i]
         X = (i0 - base(0)) * dx(0) + foffX
         Y = (i1 - base(1)) * dx(1) + foffY
         X = tan(X - fourth * Pi)
         Y = tan(Y - fourth * Pi)
         X2 = X * X
         Y2 = Y * Y
         delta = sqrt(one + X2 + Y2)

         aji = delta * delta * delta / ((one + X2) * (one + Y2))
         aji = aji + fac0 *
     &        ((one + X2) * (one + X2) * (one + two * X2)
     &        + Y2 * (X2 - one) * (one + X2 + two * Y2)) /
     &        (delta * (one + X2) * (one + Y2))
         aji = aji + fac1 *
     &        ((one + Y2) * (one + Y2) * (one + two * Y2)
     &        + X2 * (Y2 - one) * (one + Y2 + two * X2)) /
     &        (delta * (one + X2) * (one + Y2))
#if CH_SPACEDIM == 3
!     FIXME: Need dir .eq. 2 case, which reduces to 2D cell average.
         rho = (i2 - base(2)) * dx(2)
#endif
         avjinv(CHF_AUTOIX[i]) = aji
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2dpointj(
!
!     => inputs,  <= outputs
!     pointj <= J at points in mapped space
!     xi     => points in mapped space
!     panel  => panel number
!     bx     => box
!     dx     => mesh spacing
!     base   => base of panel
     &     CHF_FRA1[pointj],
     &     CHF_CONST_FRA[xi],
     &     CHF_CONST_INT[panel],
     &     CHF_BOX[bx],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_INTVECT[base])

#if CH_SPACEDIM == 3
      real_t rho, derivrmappedtoreal
#endif         
#if CH_SPACEDIM >= 2
      integer CHF_AUTODECL[i]
      real_t X, Y, X2, Y2, delta
      CHF_AUTOMULTIDO[bx; i]
         X = tan( xi(CHF_AUTOIX[i], 0) - fourth * Pi)
         Y = tan( xi(CHF_AUTOIX[i], 1) - fourth * Pi)
         X2 = X * X
         Y2 = Y * Y
         delta = sqrt(one + X2 + Y2)
         pointj(CHF_AUTOIX[i]) = (one + X2) * (one + Y2) /
     &        (delta*delta*delta)
#if CH_SPACEDIM == 3
         rho = xi(CHF_AUTOIX[i], 2)
         pointj(CHF_AUTOIX[i]) = pointj(CHF_AUTOIX[i]) *
     &        derivrmappedtoreal(rho)
#endif         
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2dvectorrealtomappedcenter(
!
!     => inputs,  <= outputs
!     vec   <=> vectors to transform
!     panel  => panel number
!     bx     => box
!     dx     => mesh spacing
!     base   => base of panel
!
!     Change basis of vectors vec at centers of cells of bx.
!
!     On input, the components are in the Cartesian unit vectors
!     ihat, jhat, khat.
!     On output, the components are in the unit vectors
!     xihat, etahat, rhat.
     &     CHF_FRA[vec],
     &     CHF_CONST_INT[panel],
     &     CHF_BOX[bx],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_INTVECT[base])

#if CH_SPACEDIM >= 2
      integer CHF_AUTODECL[i]
      real_t xi, eta, vx, vy, vz, tvxi, tveta
#if CH_SPACEDIM == 3
      real_t xu, yu, zu
#endif

      CHF_AUTOMULTIDO[bx; i]
         xi = i0 * dx(0) + half * dx(0)
         eta = i1 * dx(1) + half * dx(1)
         vx = vec(CHF_AUTOIX[i], 0)
         vy = vec(CHF_AUTOIX[i], 1)
         vz = vec(CHF_AUTOIX[i], 2)
         call vectorcartesiantoequiangular(
     &        tvxi, tveta, xi, eta, panel, vx, vy, vz)
         vec(CHF_AUTOIX[i], 0) = tvxi
         vec(CHF_AUTOIX[i], 1) = tveta
#if CH_SPACEDIM == 3
!     Vector is vx*ihat + vy*jhat + vz*khat.
!     Need to set vec(CHF_AUTOIX[i], 2) to radial component of this vector,
!     which is rhat dot (vx*ihat + vy*jhat + vz*khat).
!     Find xu, yu, zu on unit sphere:
         call equiangulartocartesian(xu, yu, zu, xi, eta, panel)
!     Then rhat = xu*ihat + yu*jhat + zu*khat.
!     So radial component of our vector is
!     (xu*ihat + yu*jhat + zu*khat) dot ((vx*ihat + vy*jhat + vz*khat).
         vec(CHF_AUTOIX[i], 2) = xu*vx + yu*vy + zu*vz
#endif
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2dequiangulartocartesian(
     &     CHF_R1D[xyz],
     &     CHF_CONST_REALVECT[xi],
     &     CHF_CONST_INT[panel])

#if CH_SPACEDIM >= 2

#if CH_SPACEDIM == 3
      integer dir
      real_t r, rmappedtoreal
#endif
      call equiangulartocartesian(
     &     xyz(0), xyz(1), xyz(2), xi(0), xi(1), panel)
#if CH_SPACEDIM == 3
      r = rmappedtoreal(xi(2))
      do dir = 0, CH_SPACEDIM-1
         xyz(dir) = r * xyz(dir)
      enddo
#endif

#endif

      return
      end


      subroutine cubedsphere2dequiangulartolonlat(
     &     CHF_REALVECT[lonlat],
     &     CHF_CONST_REALVECT[xi],
     &     CHF_CONST_INT[panel],
     &     CHF_CONST_REAL[eps])

#if CH_SPACEDIM >= 2
      call equiangulartolonlat(
     &     lonlat(0), lonlat(1), xi(0), xi(1), panel, eps)
#if CH_SPACEDIM == 3
      lonlat(2) = xi(2)
#endif
#endif

      return
      end


      subroutine cubedsphere2dfabequiangulartocartesian(
     &     CHF_FRA[xyz],
     &     CHF_CONST_FRA[xi],
     &     CHF_CONST_INT[panel])

#if CH_SPACEDIM >= 2
      integer CHF_AUTODECL[i]
#if CH_SPACEDIM == 3
      real_t r, rmappedtoreal
      integer dir
#endif
      CHF_AUTOMULTIDO[xi; i]
         call equiangulartocartesian(
     &     xyz(CHF_AUTOIX[i], 0),
     &     xyz(CHF_AUTOIX[i], 1),
     &     xyz(CHF_AUTOIX[i], 2),
     &     xi(CHF_AUTOIX[i], 0),
     &     xi(CHF_AUTOIX[i], 1),
     &     panel)
#if CH_SPACEDIM == 3
         r = rmappedtoreal(xi(CHF_AUTOIX[i], 2))
         do dir = 0, CH_SPACEDIM-1
            xyz(CHF_AUTOIX[i], dir) = r * xyz(CHF_AUTOIX[i], dir)
         enddo
#endif
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2dfabequiangulartolonlat(
     &     CHF_FRA[lonlat],
     &     CHF_CONST_FRA[xi],
     &     CHF_CONST_INT[panel],
     &     CHF_CONST_REAL[eps])

#if CH_SPACEDIM >= 2
      integer CHF_AUTODECL[i]

      CHF_AUTOMULTIDO[xi; i]
         call equiangulartolonlat(
     &     lonlat(CHF_AUTOIX[i], 0),
     &     lonlat(CHF_AUTOIX[i], 1),
     &     xi(CHF_AUTOIX[i], 0),
     &     xi(CHF_AUTOIX[i], 1),
     &     panel, eps)
#if CH_SPACEDIM == 3
         lonlat(CHF_AUTOIX[i], 2) = xi(CHF_AUTOIX[i], 2)
#endif
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2dfabvectorlatlontoequiangular(
!
!     => inputs,  <= outputs
!     xi     => mapped coordinates
!     vecRLL => vector in longitude-latitude basis
!     vecCS  <= vector in equiangular coordinate basis
!     panel  => panel number
!
!     Convert from longitude and latitude to equiangular coordinates.
!
     &     CHF_CONST_FRA[xi],
     &     CHF_CONST_FRA[vecRLL],
     &     CHF_FRA[vecCS],
     &     CHF_CONST_INT[panel])

#if CH_SPACEDIM >= 2
      integer CHF_AUTODECL[i]
      integer sgnpol
      real_t dgx, dgy, delta2, lat, x2p1, y2p1, gnor2, gnor, srx2p1
      real_t veclon, veclat

      CHF_AUTOMULTIDO[xi; i]
      dgx = tan(xi(CHF_AUTOIX[i], 0) - fourth * Pi)
      dgy = tan(xi(CHF_AUTOIX[i], 1) - fourth * Pi)
      x2p1 = one + dgx*dgx
      y2p1 = one + dgy*dgy
      gnor2 = dgx*dgx + dgy*dgy
      delta2 = one + gnor2
      veclat = vecRLL(CHF_AUTOIX[i], 1)
      if (panel .lt. 4) then
!     equatorial panel
         srx2p1 = sqrt(x2p1)
         lat = atan(dgy / srx2p1)
         veclon = vecRLL(CHF_AUTOIX[i], 0) / cos(lat)

         vecCS(CHF_AUTOIX[i], 0) = veclon
         vecCS(CHF_AUTOIX[i], 1) = (one/y2p1) *
     &        (dgx * dgy * veclon +
     &        delta2 / srx2p1 * veclat)
      else
!     polar panel
         if (panel .eq. 4) then
            sgnpol = 1
         elseif (panel .eq. 5) then
            sgnpol = -1
         endif
         gnor = sqrt(gnor2)
         lat = sgnpol * (half * Pi - atan(gnor))
         veclon = vecRLL(CHF_AUTOIX[i], 0) / cos(lat)

         vecCS(CHF_AUTOIX[i], 0) = sgnpol * (one/x2p1) *
     &        (-dgy * veclon
     &        - delta2 * dgx / gnor * veclat)
         vecCS(CHF_AUTOIX[i], 1) = sgnpol * (one/y2p1) *
     &        (dgx * veclon
     &        - delta2 * dgy / gnor * veclat)
      endif
#if CH_SPACEDIM == 3
      vecCS(CHF_AUTOIX[i], 2) = vecRLL(CHF_AUTOIX[i], 2)
#endif
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2dfabvectorequiangulartolatlon(
!
!     => inputs,  <= outputs
!     xi     => mapped coordinates
!     vecCS  => vector in equiangular coordinate basis
!     vecRLL <= vector in longitude-latitude basis
!     panel  => panel number
!
!     Convert from longitude and latitude to equiangular coordinates.
!
     &     CHF_CONST_FRA[xi],
     &     CHF_CONST_FRA[vecCS],
     &     CHF_FRA[vecRLL],
     &     CHF_CONST_INT[panel])

#if CH_SPACEDIM >= 2
      integer CHF_AUTODECL[i]
      integer sgnpol
      real_t dgx, dgy, delta2, x2p1, srx2p1, y2p1, lat
      real_t gnor, gnor2
      real_t veca, vecb

      CHF_AUTOMULTIDO[xi; i]
      dgx = tan(xi(CHF_AUTOIX[i], 0) - fourth * Pi)
      dgy = tan(xi(CHF_AUTOIX[i], 1) - fourth * Pi)
      delta2 = one + dgx*dgx + dgy*dgy
      veca = vecCS(CHF_AUTOIX[i], 0)
      vecb = vecCS(CHF_AUTOIX[i], 1)
      x2p1 = one + dgx*dgx
      y2p1 = one + dgy*dgy
      if (panel .lt. 4) then
!     equatorial panel
         srx2p1 = sqrt(x2p1)
         lat = atan(dgy / srx2p1)

         vecRLL(CHF_AUTOIX[i], 0) = cos(lat) * veca
         vecRLL(CHF_AUTOIX[i], 1) = (srx2p1 / delta2) *
     &        (-dgx*dgy * veca + y2p1 * vecb)
      else
!     polar panel
         if (panel .eq. 4) then
            sgnpol = 1
         elseif (panel .eq. 5) then
            sgnpol = -1
         endif
         gnor2 = dgx*dgx + dgy*dgy
         gnor = sqrt(gnor2)
         lat = sgnpol * (half * Pi - atan(gnor))

         vecRLL(CHF_AUTOIX[i], 0) = sgnpol * (cos(lat)/gnor2) *
     &        (-x2p1 * dgy * veca + dgx * y2p1 * vecb)
         vecRLL(CHF_AUTOIX[i], 1) = sgnpol * (one/(gnor*delta2)) *
     &        (-dgx * x2p1 * veca - dgy * y2p1 * vecb)
      endif
#if CH_SPACEDIM == 3
      vecRLL(CHF_AUTOIX[i], 2) = vecCS(CHF_AUTOIX[i], 2)
#endif
      CHF_ENDDO
#endif

      return
      end


      subroutine orthonormalize(
!
!     => inputs,  <= outputs
!     xi     => mapped coordinates
!     csVec  => vector in frame of mapped coordinates
!     onVec  <= vector in orthonormal frame
!     idir   => normal direction
!     csComp => indices of components of vector in csVec
!     onComp => indices of components of vector in onVec
!
!     Convert vectors from frame of mapped coordinates to orthonormal frame.
!
!     If we call the mapped coordinates alpha and beta, where the valid
!     ranges are alpha in (0:pi/2)+iblock*pi, beta in (0:pi/2), then
!     setting X = tan(alpha-pi/4), Y = tan(beta-pi/4), delta = sqrt(1+X*X+Y*Y),
!     the orthonormalization matrix on grid lines of constant alpha is
!     O1 = sqrt(1+X*X)/(delta*delta) * (delta    0  )
!                                      (-X*Y   1+Y*Y)
!     and the orthonormalization matrix on grid lines of constant beta is
!     O2 = sqrt(1+Y*Y)/(delta*delta) * (  0    delta)
!                                      (1+X*X  -X*Y )
!
!     Source:  Ullrich et al., "High-order finite volume methods for the
!     shallow-water equations on the sphere", JCP, 229:6104--6134 (2010),
!     equations (27)--(28).
     &     CHF_CONST_FRA[xi],
     &     CHF_CONST_FRA[csVec],
     &     CHF_FRA[onVec],
     &     CHF_CONST_INT[idir],
     &     CHF_CONST_INTVECT[csComp],
     &     CHF_CONST_INTVECT[onComp])

#if CH_SPACEDIM == 2
      integer CHF_AUTODECL[i]
      integer ion0, ion1, ics0, ics1
      real_t dgx, dgy, delta2, delta, x2p1, y2p1, srx2p1, sry2p1
      real_t csVec0, csVec1

      ics0 = csComp(0)
      ics1 = csComp(1)
      ion0 = onComp(0)
      ion1 = onComp(1)
      CHF_AUTOMULTIDO[xi; i]
         dgx = tan(xi(CHF_AUTOIX[i], 0) - fourth * Pi)
         dgy = tan(xi(CHF_AUTOIX[i], 1) - fourth * Pi)
         delta2 = one + dgx*dgx + dgy*dgy
         delta = sqrt(delta2)
         x2p1 = one + dgx*dgx
         y2p1 = one + dgy*dgy
         csVec0 = csVec(CHF_AUTOIX[i], ics0)
         csVec1 = csVec(CHF_AUTOIX[i], ics1)
         if (idir .eq. 0) then
            srx2p1 = sqrt(x2p1)
            onVec(CHF_AUTOIX[i], ion0) = srx2p1/delta * csVec0
            onVec(CHF_AUTOIX[i], ion1) = (srx2p1/delta2) *
     &           ( -dgx*dgy * csVec0 + y2p1 * csVec1 )
         elseif (idir .eq. 1) then
            sry2p1 = sqrt(y2p1)
            onVec(CHF_AUTOIX[i], ion0) = sry2p1/delta * csVec1
            onVec(CHF_AUTOIX[i], ion1) = (sry2p1/delta2) *
     &           ( x2p1 * csVec0 - dgx*dgy * csVec1 )
         else
            print *, 'Error: invalid direction ', idir
            call MAYDAY_ERROR()
         endif
      CHF_ENDDO
#endif

      return
      end


      subroutine deorthonormalize(
!
!     => inputs,  <= outputs
!     xi     => mapped coordinates
!     onVec  => vector in orthonormal frame
!     csVec  <= vector in frame of mapped coordinates
!     idir   => normal direction
!     onComp => indices of components of vector in onVec
!     csComp => indices of components of vector in csVec
!
!     Convert vectors from orthonormal frame to frame of mapped coordinates.
!
!     If we call the mapped coordinates alpha and beta, where the valid
!     ranges are alpha in (0:pi/2)+iblock*pi, beta in (0:pi/2), then
!     setting X = tan(alpha-pi/4), Y = tan(beta-pi/4), delta = sqrt(1+X*X+Y*Y),
!     the deorthonormalization matrix on grid lines of constant alpha is
!     inv(O1) = delta/((1+Y*Y)*sqrt(1+X*X)) * (1+Y*Y   0  )
!                                             ( X*Y  delta)
!     and the deorthonormalization matrix on grid lines of constant beta is
!     inv(O2) = delta/((1+X*X)*sqrt(1+Y*Y)) * ( X*Y  delta)
!                                             (1+X*X   0  )
!
!     Source:  Ullrich et al., "High-order finite volume methods for the
!     shallow-water equations on the sphere", JCP, 229:6104--6134 (2010),
!     equations (27)--(28).
!
     &     CHF_CONST_FRA[xi],
     &     CHF_CONST_FRA[onVec],
     &     CHF_FRA[csVec],
     &     CHF_CONST_INT[idir],
     &     CHF_CONST_INTVECT[onComp],
     &     CHF_CONST_INTVECT[csComp])

#if CH_SPACEDIM == 2
      integer CHF_AUTODECL[i]
      integer ion0, ion1, ics0, ics1
      real_t dgx, dgy, delta2, delta, x2p1, y2p1, srx2p1, sry2p1
      real_t onVec0, onVec1

      ion0 = onComp(0)
      ion1 = onComp(1)
      ics0 = csComp(0)
      ics1 = csComp(1)
      CHF_AUTOMULTIDO[xi; i]
         dgx = tan(xi(CHF_AUTOIX[i], 0) - fourth * Pi)
         dgy = tan(xi(CHF_AUTOIX[i], 1) - fourth * Pi)
         delta2 = one + dgx*dgx + dgy*dgy
         delta = sqrt(delta2)
         x2p1 = one + dgx*dgx
         y2p1 = one + dgy*dgy
         onVec0 = onVec(CHF_AUTOIX[i], ion0)
         onVec1 = onVec(CHF_AUTOIX[i], ion1)
         if (idir .eq. 0) then
            srx2p1 = sqrt(x2p1)
            csVec(CHF_AUTOIX[i], ics0) = delta/srx2p1 * onVec0
            csVec(CHF_AUTOIX[i], ics1) = (delta/(y2p1*srx2p1)) *
     &           ( dgx*dgy * onVec0 + delta * onVec1 )
         elseif (idir .eq. 1) then
            sry2p1 = sqrt(y2p1)
            csVec(CHF_AUTOIX[i], ics0) = (delta/(x2p1*sry2p1)) *
     &           ( dgx*dgy * onVec0 + delta * onVec1 )
            csVec(CHF_AUTOIX[i], ics1) = delta/sry2p1 * onVec0
         else
            print *, 'Error: invalid direction ', idir
            call MAYDAY_ERROR()
         endif
      CHF_ENDDO
#endif

      return
      end


      subroutine orthonormalizingmatrix(
!
!     => inputs,  <= outputs
!     xi     => mapped coordinates
!     mat    <= change-of-basis coefficients
!     idir   => normal direction
!
!     Return coefficients to change a vector from basis in frame of
!     mapped coordinates to basis in orthonormal frame.
!
!     If we call the mapped coordinates alpha and beta, where the valid
!     ranges are alpha in (0:pi/2)+iblock*pi, beta in (0:pi/2), then
!     setting X = tan(alpha-pi/4), Y = tan(beta-pi/4), delta = sqrt(1+X*X+Y*Y),
!     the orthonormalization matrix on grid lines of constant alpha is
!     O1 = sqrt(1+X*X)/(delta*delta) * (delta    0  )
!                                      (-X*Y   1+Y*Y)
!     and the orthonormalization matrix on grid lines of constant beta is
!     O2 = sqrt(1+Y*Y)/(delta*delta) * (  0    delta)
!                                      (1+X*X  -X*Y )
!
!     Source:  Ullrich et al., "High-order finite volume methods for the
!     shallow-water equations on the sphere", JCP, 229:6104--6134 (2010),
!     equations (27)--(28).
     &     CHF_CONST_FRA[xi],
     &     CHF_FRA[mat],
     &     CHF_BOX[bx],
     &     CHF_CONST_INT[idir])

#if CH_SPACEDIM == 2
      integer CHF_AUTODECL[i]
      real_t dgx, dgy, delta2, delta, x2p1, y2p1, srx2p1, sry2p1, fac

      CHF_AUTOMULTIDO[xi; i]
         dgx = tan(xi(CHF_AUTOIX[i], 0) - fourth * Pi)
         dgy = tan(xi(CHF_AUTOIX[i], 1) - fourth * Pi)
         delta2 = one + dgx*dgx + dgy*dgy
         delta = sqrt(delta2)
         x2p1 = one + dgx*dgx
         y2p1 = one + dgy*dgy
         if (idir .eq. 0) then
            srx2p1 = sqrt(x2p1)
            fac = srx2p1 / delta2
            mat(CHF_AUTOIX[i], 0) = srx2p1/delta
            mat(CHF_AUTOIX[i], 1) = zero
            mat(CHF_AUTOIX[i], 2) = fac * (-dgx * dgy)
            mat(CHF_AUTOIX[i], 3) = fac * y2p1
         elseif (idir .eq. 1) then
            sry2p1 = sqrt(y2p1)
            fac = sry2p1 / delta2
            mat(CHF_AUTOIX[i], 0) = zero
            mat(CHF_AUTOIX[i], 1) = sry2p1/delta
            mat(CHF_AUTOIX[i], 2) = fac * x2p1
            mat(CHF_AUTOIX[i], 3) = fac * (-dgx * dgy)
         else
            print *, 'Error: invalid direction ', idir
            call MAYDAY_ERROR()
         endif
      CHF_ENDDO
#endif

      return
      end


      subroutine deorthonormalizingmatrix(
!
!     => inputs,  <= outputs
!     xi     => mapped coordinates
!     mat    <= change-of-basis coefficients
!     idir   => normal direction
!
!     Return coefficients to change a vector from basis in orthonormal
!     frame to basis in mapped coordinates.
!
!     If we call the mapped coordinates alpha and beta, where the valid
!     ranges are alpha in (0:pi/2)+iblock*pi, beta in (0:pi/2), then
!     setting X = tan(alpha-pi/4), Y = tan(beta-pi/4), delta = sqrt(1+X*X+Y*Y),
!     the deorthonormalization matrix on grid lines of constant alpha is
!     inv(O1) = delta/((1+Y*Y)*sqrt(1+X*X)) * (1+Y*Y   0  )
!                                             ( X*Y  delta)
!     and the deorthonormalization matrix on grid lines of constant beta is
!     inv(O2) = delta/((1+X*X)*sqrt(1+Y*Y)) * ( X*Y  delta)
!                                             (1+X*X   0  )
!
!     Source:  Ullrich et al., "High-order finite volume methods for the
!     shallow-water equations on the sphere", JCP, 229:6104--6134 (2010),
!     equations (27)--(28).
     &     CHF_CONST_FRA[xi],
     &     CHF_FRA[mat],
     &     CHF_BOX[bx],
     &     CHF_CONST_INT[idir])

#if CH_SPACEDIM == 2
      integer CHF_AUTODECL[i]
      real_t dgx, dgy, delta2, delta, x2p1, y2p1, srx2p1, sry2p1, fac

      CHF_AUTOMULTIDO[xi; i]
         dgx = tan(xi(CHF_AUTOIX[i], 0) - fourth * Pi)
         dgy = tan(xi(CHF_AUTOIX[i], 1) - fourth * Pi)
         delta2 = one + dgx*dgx + dgy*dgy
         delta = sqrt(delta2)
         x2p1 = one + dgx*dgx
         y2p1 = one + dgy*dgy
         if (idir .eq. 0) then
            srx2p1 = sqrt(x2p1)
            fac = delta / (y2p1*srx2p1)
            mat(CHF_AUTOIX[i], 0) = delta / srx2p1
            mat(CHF_AUTOIX[i], 1) = zero
            mat(CHF_AUTOIX[i], 2) = fac * (dgx * dgy)
            mat(CHF_AUTOIX[i], 3) = delta2 / (y2p1*srx2p1)
         elseif (idir .eq. 1) then
            sry2p1 = sqrt(y2p1)
            fac = delta / (x2p1*sry2p1)
            mat(CHF_AUTOIX[i], 0) = fac * (dgx * dgy)
            mat(CHF_AUTOIX[i], 1) = delta2 / (x2p1*sry2p1)
            mat(CHF_AUTOIX[i], 2) = delta / sry2p1
            mat(CHF_AUTOIX[i], 3) = zero
         else
            print *, 'Error: invalid direction ', idir
            call MAYDAY_ERROR()
         endif
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2dcontravariantmetric(
!
!     => inputs,  <= outputs
!     xi     => mapped coordinates
!     metric <= contravariant metric
!
!     Return contravariant metric at specified points.
!     g^{ij} = (dDelta2/((1+X^2)*(1+Y^2))) * [1+Y^2, X*Y; X*Y, 1+X^2]
!
     &     CHF_CONST_FRA[xi],
     &     CHF_FRA[metric],
     &     CHF_CONST_INT[idir])

#if CH_SPACEDIM == 2
      integer CHF_AUTODECL[i]
      real_t dgx, dgy, delta2, x2p1, y2p1

      CHF_AUTOMULTIDO[xi; i]
         dgx = tan(xi(CHF_AUTOIX[i], 0) - fourth * Pi)
         dgy = tan(xi(CHF_AUTOIX[i], 1) - fourth * Pi)
         x2p1 = one + dgx*dgx
         y2p1 = one + dgy*dgy
         delta2 = one + dgx*dgx + dgy*dgy
         if (idir .eq. 0) then
            metric(CHF_AUTOIX[i], 0) = delta2 / x2p1
            metric(CHF_AUTOIX[i], 1) = delta2*dgx*dgy / (x2p1*y2p1)
         elseif (idir .eq. 1) then
            metric(CHF_AUTOIX[i], 0) = delta2*dgx*dgy / (x2p1*y2p1)
            metric(CHF_AUTOIX[i], 1) = delta2 / y2p1
         else
            print *, 'Error: invalid direction ', idir
            call MAYDAY_ERROR()
         endif
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2ddotprod(
!
!     => inputs,  <= outputs
!     xi    => mapped coordinates
!     u, v  => vector fields, each with CH_SPACEDIM components
!     prod  <= dot product
!     bx    => box on which we return the dot product
!
!     Return dot product of two vector fields.
!
     &     CHF_CONST_FRA[xi],
     &     CHF_CONST_FRA[u],
     &     CHF_CONST_FRA[v],
     &     CHF_FRA1[prod],
     &     CHF_BOX[bx])

#if CH_SPACEDIM >= 2
      integer CHF_AUTODECL[i]
      real_t dgx, dgy, crossf
      real_t u0, u1, v0, v1

      CHF_AUTOMULTIDO[bx; i]
         dgx = tan(xi(CHF_AUTOIX[i], 0) - fourth * Pi)
         dgy = tan(xi(CHF_AUTOIX[i], 1) - fourth * Pi)
         crossf = (dgx*dgy) / (sqrt((one + dgx*dgx) * (one + dgy*dgy)))
!     Could also write this as product over d=0:1 of
!     sin(xi[[d]-pi/4) * sign(cos(xi[d]-pi/4)).
         u0 = u(CHF_AUTOIX[i], 0)
         u1 = u(CHF_AUTOIX[i], 1)
         v0 = v(CHF_AUTOIX[i], 0)
         v1 = v(CHF_AUTOIX[i], 1)
         prod(CHF_AUTOIX[i]) = u0*v0 + u1*v1 - (u0*v1+u1*v0)*crossf
#if CH_SPACEDIM == 3
         prod(CHF_AUTOIX[i]) = prod(CHF_AUTOIX[i]) +
     &        u(CHF_AUTOIX[i], 2) * v(CHF_AUTOIX[i], 2)
#endif
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2dcurlr(
!
!     => inputs,  <= outputs
!     xi      => mapped coordinates
!     deriv0  => x[0]-derivative of components of vector field
!     deriv1  => x[1]-derivative of components of vector field
!     curlr   <= radial component of the curl
!     bx      => box on which we return the curl
!
!     Return radial component of the curl of a vector field,
!     given partial derivatives of its components.
!
!     Compute derivatives first by calling FORT_UDIVCENTERGRAD and
!     dividing by mesh spacing.
!
     &     CHF_CONST_FRA[xi],
     &     CHF_CONST_FRA[deriv0],
     &     CHF_CONST_FRA[deriv1],
     &     CHF_FRA1[curlr],
     &     CHF_BOX[bx])

#if CH_SPACEDIM == 2
      integer CHF_AUTODECL[i]
      real_t dgx, dgy, delta, x2p1, y2p1, srx2p1, sry2p1

      CHF_AUTOMULTIDO[bx; i]
         dgx = tan(xi(CHF_AUTOIX[i], 0) - fourth * Pi)
         dgy = tan(xi(CHF_AUTOIX[i], 1) - fourth * Pi)
         delta = sqrt(one + dgx*dgx + dgy*dgy)
         x2p1 = one + dgx*dgx
         y2p1 = one + dgy*dgy
         srx2p1 = sqrt(x2p1)
         sry2p1 = sqrt(y2p1)
         curlr(CHF_AUTOIX[i]) = delta *
     &        ( ((dgx*dgy) / (srx2p1*sry2p1)) *
     &        ( deriv1(CHF_AUTOIX[i], 1) / sry2p1
     &        - deriv0(CHF_AUTOIX[i], 0) / srx2p1 )
     &        - deriv1(CHF_AUTOIX[i], 0) / sry2p1
     &        + deriv0(CHF_AUTOIX[i], 1) / srx2p1 )
      CHF_ENDDO
#endif

      return
      end


      subroutine cubedsphere2dpartials(
!
!     Returns dalpha/dlon, dbeta/dlon, dalpha/dlat, dbeta/dlat.
!     
     &     CHF_CONST_FRA[lonlat],
     &     CHF_FRA[derivs],
     &     CHF_CONST_INT[panel],
     &     CHF_BOX[bx])

#if CH_SPACEDIM == 2
      integer CHF_AUTODECL[i]
      real_t lon, lat

      if (panel .eq. 0) then
         CHF_AUTOMULTIDO[bx; i]
         lon = lonlat(CHF_AUTOIX[i], 0)
         lat = lonlat(CHF_AUTOIX[i], 1)
         derivs(CHF_AUTOIX[i], 0) = one
         derivs(CHF_AUTOIX[i], 1) =
     &        one/(Cos(lon)/Tan(lat)/Tan(lon) + Tan(lat)/Sin(lon))
         derivs(CHF_AUTOIX[i], 2) = zero
         derivs(CHF_AUTOIX[i], 3) =
     &        one/(Cos(lat)**2*Cos(lon) + Sin(lat)**2/Cos(lon))
         CHF_ENDDO
      elseif (panel .eq. 1) then
         CHF_AUTOMULTIDO[bx; i]
         lon = lonlat(CHF_AUTOIX[i], 0)
         lat = lonlat(CHF_AUTOIX[i], 1)
         derivs(CHF_AUTOIX[i], 0) = one
         derivs(CHF_AUTOIX[i], 1) = 
     &        -((Tan(lat)/Tan(lon)/Sin(lon))/
     &        (one + Tan(lat)**2/Sin(lon)**2))
         derivs(CHF_AUTOIX[i], 2) = zero
         derivs(CHF_AUTOIX[i], 3) =
     &        one/(Sin(lat)**2/Sin(lon) + Cos(lat)**2*Sin(lon))
         CHF_ENDDO
      elseif (panel .eq. 2) then
         CHF_AUTOMULTIDO[bx; i]
         lon = lonlat(CHF_AUTOIX[i], 0)
         lat = lonlat(CHF_AUTOIX[i], 1)
         derivs(CHF_AUTOIX[i], 0) = one
         derivs(CHF_AUTOIX[i], 1) =
     &        -(one/(Cos(lon)/Tan(lat)/Tan(lon) + Tan(lat)/Sin(lon)))
         derivs(CHF_AUTOIX[i], 2) = zero
         derivs(CHF_AUTOIX[i], 3) =
     &        -(one/(Cos(lat)**2*Cos(lon) + Sin(lat)**2/Cos(lon)))
         CHF_ENDDO
      elseif (panel .eq. 3) then
         CHF_AUTOMULTIDO[bx; i]
         lon = lonlat(CHF_AUTOIX[i], 0)
         lat = lonlat(CHF_AUTOIX[i], 1)
         derivs(CHF_AUTOIX[i], 0) = one
         derivs(CHF_AUTOIX[i], 1) =
     &        (Tan(lat)/Tan(lon)/Sin(lon))/
     &        (one + Tan(lat)**2/Sin(lon)**2)
         derivs(CHF_AUTOIX[i], 2) = zero
         derivs(CHF_AUTOIX[i], 3) =
     &        -(one/(Sin(lat)**2/Sin(lon) + Cos(lat)**2*Sin(lon)))
         CHF_ENDDO
      elseif (panel .eq. 4) then
         CHF_AUTOMULTIDO[bx; i]
         lon = lonlat(CHF_AUTOIX[i], 0)
         lat = lonlat(CHF_AUTOIX[i], 1)
         derivs(CHF_AUTOIX[i], 0) =
     &        (Cos(lon)/Tan(lat))/(one + Sin(lon)**2/Tan(lat)**2)
         derivs(CHF_AUTOIX[i], 1) =
     &        (Sin(lon)/Tan(lat))/(one + Cos(lon)**2/Tan(lat)**2)
         derivs(CHF_AUTOIX[i], 2) =
     &        -(one/(Sin(lat)**2/Sin(lon) + Cos(lat)**2*Sin(lon)))
         derivs(CHF_AUTOIX[i], 3) =
     &        (Cos(lon)/Sin(lat)**2)/(one + Cos(lon)**2/Tan(lat)**2)
         CHF_ENDDO
      elseif (panel .eq. 5) then
         CHF_AUTOMULTIDO[bx; i]
         lon = lonlat(CHF_AUTOIX[i], 0)
         lat = lonlat(CHF_AUTOIX[i], 1)
         derivs(CHF_AUTOIX[i], 0) =
     &        -((Cos(lon)/Tan(lat))/(one + Sin(lon)**2/Tan(lat)**2))
         derivs(CHF_AUTOIX[i], 1) =
     &        (Sin(lon)/Tan(lat))/(one + Cos(lon)**2/Tan(lat)**2)
         derivs(CHF_AUTOIX[i], 2) =
     &        one/(Sin(lat)**2/Sin(lon) + Cos(lat)**2*Sin(lon))
         derivs(CHF_AUTOIX[i], 3) =
     &        (Cos(lon)/Sin(lat)**2)/(one + Cos(lon)**2/Tan(lat)**2)
         CHF_ENDDO
      else
         print *, 'Error: invalid panel ', panel
         call MAYDAY_ERROR()
      endif
#endif

      return
      end


      subroutine cubedsphere2dmappedtocartesian(
!
!     => inputs,  <= outputs
!     x, y, z <= Cartesian coordinates
!     xi      => mapped coordinates
!     panel   => panel number
     &     CHF_REAL[x],
     &     CHF_REAL[y],
     &     CHF_REAL[z],
     &     CHF_CONST_REALVECT[xi],
     &     CHF_CONST_INT[panel])

#if CH_SPACEDIM >= 2
#if CH_SPACEDIM >= 3
      real_t rreal, rmappedtoreal
#endif
      call equiangulartocartesian(x, y, z, xi(0), xi(1), panel)
#if CH_SPACEDIM >= 3
      rreal = rmappedtoreal(xi(2))
      x = rreal * x
      y = rreal * y
      z = rreal * z
#endif
#endif

      return
      end


      subroutine cubedsphere2dcartesiantomapped(
!
!     => inputs,  <= outputs
!     xi      <= mapped coordinates
!     x, y, z => Cartesian coordinates
!     panel   => panel number
     &     CHF_REALVECT[xi],
     &     CHF_CONST_REAL[x],
     &     CHF_CONST_REAL[y],
     &     CHF_CONST_REAL[z],
     &     CHF_CONST_INT[panel])

#if CH_SPACEDIM >= 2
#if CH_SPACEDIM >= 3
      real_t rreal, rmappedtoreal
#endif
      if (panel .eq. 0) then
         xi(0) = fourth*Pi + atan(y/x) + panel*Pi
         xi(1) = fourth*Pi + atan(z/x)
      elseif (panel .eq. 1) then
         xi(0) = fourth*Pi + atan(-x/y) + panel*Pi
         xi(1) = fourth*Pi + atan(z/y)
      elseif (panel .eq. 2) then
         xi(0) = fourth*Pi + atan(y/x) + panel*Pi
         xi(1) = fourth*Pi + atan(-z/x)
      elseif (panel .eq. 3) then
         xi(0) = fourth*Pi + atan(-x/y) + panel*Pi
         xi(1) = fourth*Pi + atan(-z/y)
      elseif (panel .eq. 4) then
         xi(0) = fourth*Pi + atan(y/z) + panel*Pi
         xi(1) = fourth*Pi + atan(-x/z)
      elseif (panel .eq. 5) then
         xi(0) = fourth*Pi + atan(-y/z) + panel*Pi
         xi(1) = fourth*Pi + atan(-x/z)
      else
         print *, 'Error: invalid panel ', panel
         call MAYDAY_ERROR()
      endif
#if CH_SPACEDIM >= 3
      rreal = rmappedtoreal(x**2 + y**2 + z**2)
      xi(2) = rreal
#endif
#endif

      return
      end


      subroutine cubedsphere2ddisplacements(
!
!     => inputs,  <= outputs
!     disp   <= displacements in some kind of real space, source to destinations
!     dCoord => mapped coordinates of destination points
!     dPanel => panel indices of destination points
!     sCoord => mapped coordinates of source point
!     sPanel => panel indices of source point
     &     CHF_VR[disp],
     &     CHF_CONST_VR[dCoord],
     &     CHF_CONST_VI[dPanel],
     &     CHF_CONST_REALVECT[sCoord],
     &     CHF_CONST_INT[sPanel])

#if CH_SPACEDIM >= 2
      real_t xusrc, yusrc, zusrc, denom, xfinal, xaxis, yaxis, zaxis
      real_t dxi, deta, xdst, ydst, zdst, saxdst
      real_t yrot, zrot, lat, lon
      integer dind, diMax, arrind, panel
#if CH_SPACEDIM >= 3
      real_t srmap, srreal, drmap, drreal, rmean
      real_t rmappedtoreal
#endif
!     Get (xusrc, yusrc, zusrc) on unit sphere.
      call equiangulartocartesian(xusrc, yusrc, zusrc,
     &     sCoord(0), sCoord(1), sPanel)
!     Find the matrix that rotates points on the unit sphere
!     in such a way that (xusrc, yusrc, zusrc) gets rotated to (1, 0, 0).

!     Because of a singularity at (-1, 0, 0), if xusrc < 0 then
!     first map (xusrc, yusrc, zusrc) to (-1, 0, 0), then later to (1, 0, 0).
      xfinal = one
      if (xusrc .lt. zero) xfinal = -one
      
      denom = sqrt((xusrc + xfinal)**2 + yusrc**2 + zusrc**2)
!     Set (xaxis, yaxis, zaxis) to unit vector in direction of axis of rotation.
      xaxis = (xusrc + xfinal) / denom
      yaxis = yusrc / denom
      zaxis = zusrc / denom
#if CH_SPACEDIM >= 3
      srmap = sCoord(2)
      srreal = rmappedtoreal(srmap)
#endif
      diMax = CHF_UBOUND[dPanel]
      arrind = 0
      do dind = 0, diMax
         dxi = dCoord(arrind)
         deta = dCoord(arrind + 1)
         panel = dPanel(dind)
         call equiangulartocartesian(xdst, ydst, zdst,
     &        dxi, deta, panel)
         saxdst = xaxis * xdst + yaxis * ydst + zaxis * zdst
         yrot = xfinal * ( (two*yaxis) * saxdst - ydst )
         zrot = (two*zaxis) * saxdst - zdst
         lat = acos(zrot)
         lon = asin(yrot / sin(lat))
         disp(arrind) = lon
         disp(arrind + 1) = half*Pi - lat
#if CH_SPACEDIM >= 3
         drmap = dCoord(arrind + 2)
         drreal = rmappedtoreal(drmap)
         rmean = (srreal + drreal) * half
         disp(arrind)     = rmean * disp(arrind)
         disp(arrind + 1) = rmean * disp(arrind + 1)
         disp(arrind + 2) = drreal - srreal
#endif
         arrind = arrind + CH_SPACEDIM
      enddo
#endif

      return
      end
