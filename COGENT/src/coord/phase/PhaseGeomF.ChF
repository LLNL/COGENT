#include "CONSTANTS.H"
c  NOTE in this file CH_SPACEDIM is total phase space dimension

      subroutine compute_gk_velocity(
     &     CHF_CONST_INT[dir],
     &     CHF_BOX[gridbox],
     &     CHF_CONST_REALVECT[h],
     &     CHF_CONST_REAL[Z],
     &     CHF_CONST_REAL[mass],
     &     CHF_CONST_REAL[larmor],
     &     CHF_CONST_INT[include_drifts],
     &     CHF_CONST_INT[include_par_streaming],
     &     CHF_CONST_INT[include_gradB_par_force],
     &     CHF_CONST_INT[include_mag_drifts],
     &     CHF_CONST_INT[mag_drifts_only],
     &     CHF_CONST_INT[use_field_alignment],
     &     CHF_CONST_INT[use_locnormalized_vels],
     &     CHF_CONST_FRA[E],
     &     CHF_CONST_FRA[Bvec],
     &     CHF_CONST_FRA[gradB],
     &     CHF_CONST_FRA[curlb],
     &     CHF_CONST_FRA[vnorm],
     &     CHF_CONST_FRA[gradlogvparn],
     &     CHF_CONST_FRA[gradlogmun],
     &     CHF_FRA[velocity],
     &     CHF_CONST_INT[is_gyrokinetic]
     &     )

c    For spatial normalization of vpar, mu, use_normalized_coords = 1 (true),
c    and then vnorm, gradlogvparn and gradlogmun are the (vector) normalization velocity
c    (vparnorm, munorm) and the logarithmic gradients of the vparallel and mu
c    normalization functions.  

c     local variables
      double precision vpar, mu, Bmag, Bstar_par, G(0:2), b(0:2), Bstar(0:2),
     &     bxG(0:2), mag_drift_fac(0:2), Bstar_dot_G, fac, this_Bvec(0:2),
     &     this_curlb(0:2), this_gradB(0:2), this_E(0:2), this_vparnorm, this_munorm,
     &     this_gradlogvparn(0:2),this_gradlogmun(0:2),gradvn_dot_rdot,gradmun_dot_rdot,
     &	   vparcomp,mucomp
      integer CHF_AUTODECL[i], n, phys_comp(0:2), dimless2, dimless1, dimless3

      dimless2 = CH_SPACEDIM-2
      dimless1 = CH_SPACEDIM-1
      dimless3 = CH_SPACEDIM-3

      if (include_drifts .ne. 0) then
         fac = larmor / Z
      else
         fac = zero
      endif

      phys_comp(0) = 0
      phys_comp(1) = 6 - CH_SPACEDIM
      phys_comp(2) = 2

      CHF_AUTOMULTIDO[gridbox;i]

c     vpar, mu are the physical (real) velocity components
c     vparcomp, mucomp are the computational (mapped) components  

#if CH_SPACEDIM==4
            vparcomp  = ( i2 + half*(1-CHF_ID(dimless2,dir)) ) * h(dimless2)
            mucomp    = ( i3 + half*(1-CHF_ID(dimless1,dir)) ) * h(dimless1)
            if (use_locnormalized_vels .EQ. 1) then
               this_vparnorm = vnorm(i0,i1,CHF_LBOUND[vnorm;2] ,CHF_LBOUND[vnorm;3],0)
               this_munorm = vnorm(i0,i1,CHF_LBOUND[vnorm;2] ,CHF_LBOUND[vnorm;3],1)
               if (dir .GE. dimless2) then	       
	         do n=0,1
	             this_gradlogvparn(n)=gradlogvparn(i0,i1,CHF_LBOUND[gradlogvparn;2],
     &                     CHF_LBOUND[gradlogvparn;3],n)
                     this_gradlogmun(n)=gradlogmun(i0,i1,CHF_LBOUND[gradlogmun;2],
     &                     CHF_LBOUND[gradlogmun;3],n)
	         enddo
               endif
            endif      
#endif
#if CH_SPACEDIM==5
            vparcomp  = ( i3 + half*(1-CHF_ID(dimless2,dir)) ) * h(dimless2)
            mucomp    = ( i4 + half*(1-CHF_ID(dimless1,dir)) ) * h(dimless1)
            if (use_locnormalized_vels .EQ. 1) then
	      this_vparnorm = vnorm(i0,i1,i2,CHF_LBOUND[vnorm;3] ,CHF_LBOUND[vnorm;4],0)
              this_munorm = vnorm(i0,i1,i2,CHF_LBOUND[vnorm;3] ,CHF_LBOUND[vnorm;4],1)
              if (dir .GE. dimless2) then
	        do n=0,2
                     this_gradlogvparn(n)=gradlogvparn(i0,i1,i2,CHF_LBOUND[gradlogvparn;3],
     &                   CHF_LBOUND[gradlogvparn;4],n)
                     this_gradlogmun(n)=gradlogmun(i0,i1,i2,CHF_LBOUND[gradlogmun;3],
     &                   CHF_LBOUND[gradlogmun;4],n)
	        enddo
              endif
            endif
#endif
         if (use_locnormalized_vels .EQ. 1) then
      	    vpar = vparcomp*this_vparnorm
            mu = mucomp*this_munorm
         else
             vpar = vparcomp
             mu = mucomp
         endif

         Bmag = zero
         do n = 0, 2

#if CH_SPACEDIM==4
            this_Bvec(n)  =  Bvec(i0,i1,CHF_LBOUND[Bvec;2] ,CHF_LBOUND[Bvec;3] ,n)
            this_curlb(n) = curlb(i0,i1,CHF_LBOUND[curlb;2],CHF_LBOUND[curlb;3],n)
            this_gradB(n) = gradB(i0,i1,CHF_LBOUND[gradB;2],CHF_LBOUND[gradB;3],n)
            if (is_gyrokinetic .EQ. 0) then
              this_E(n) = E(i0,i1,CHF_LBOUND[E;2],CHF_LBOUND[E;3],n)
            else
              this_E(n) = E(i0,i1,CHF_LBOUND[E;2],i3,n)
            endif
#endif
#if CH_SPACEDIM==5
            this_Bvec(n)  =  Bvec(i0,i1,i2,CHF_LBOUND[Bvec;3] ,CHF_LBOUND[Bvec;4] ,n)
            this_curlb(n) = curlb(i0,i1,i2,CHF_LBOUND[curlb;3],CHF_LBOUND[curlb;4],n)
            this_gradB(n) = gradB(i0,i1,i2,CHF_LBOUND[gradB;3],CHF_LBOUND[gradB;4],n)
            if (is_gyrokinetic .EQ. 0) then
              this_E(n) = E(i0,i1,i2,CHF_LBOUND[E;3],CHF_LBOUND[E;4],n)
            else
              this_E(n) = E(i0,i1,i2,CHF_LBOUND[E;3],i4,n)
            endif
#endif
            Bmag = Bmag + this_Bvec(n)**2
         enddo
         Bmag = dsqrt(Bmag)

         Bstar_par = zero
         do n = 0, 2
            G(n) = -Z * this_E(n)

            if (mag_drifts_only.ne.0) then
               G(n) = 0.0
            endif 

            b(n) = this_Bvec(n) / Bmag
            mag_drift_fac(n) = fac * mass * vpar * this_curlb(n)
            Bstar(n) = this_Bvec(n) + mag_drift_fac(n)

            Bstar_par = Bstar_par + b(n) * Bstar(n)
         enddo

         if (include_mag_drifts .ne. 0) then
            do n = 0, 2
               G(n) = G(n) + half * mu * this_gradB(n)
            enddo
         endif

c        R_dot

         bxG(0) = b(1)*G(2) - b(2)*G(1)
         bxG(1) = b(2)*G(0) - b(0)*G(2)
         bxG(2) = b(0)*G(1) - b(1)*G(0)

         do n = 0, dimless3
            velocity(CHF_AUTOIX[i],n)  = fac*bxG(phys_comp(n))

            if (include_mag_drifts .ne. 0) then
               velocity(CHF_AUTOIX[i],n) = velocity(CHF_AUTOIX[i],n) 
     &              + vpar * mag_drift_fac(phys_comp(n))
            endif 


            if ((include_par_streaming .ne. 0) .and. (.not.((use_field_alignment .ne. 0). and. (dir.ne.1)))) then
               velocity(CHF_AUTOIX[i],n) = velocity(CHF_AUTOIX[i],n) 
     &              + vpar * this_Bvec(phys_comp(n))
            endif

            velocity(CHF_AUTOIX[i],n)  = velocity(CHF_AUTOIX[i],n) / Bstar_par
         enddo

c        vpar_dot

         Bstar_dot_G = zero
         do n = 0, 2

            Bstar_dot_G = Bstar_dot_G + Bstar(n) * G(n)

            if (include_gradB_par_force .eq. 0) then
              Bstar_dot_G = Bstar_dot_G - this_Bvec(n) * half * mu * this_gradB(n)   
            endif
         enddo

         velocity(CHF_AUTOIX[i],dimless2) = - Bstar_dot_G / (mass * Bstar_par)

         if (use_locnormalized_vels .EQ. 1) then
           gradvn_dot_rdot = zero
           do n = 0, dimless3
              gradvn_dot_rdot = gradvn_dot_rdot + this_gradlogvparn(n)*velocity(CHF_AUTOIX[i],n)
           enddo
           velocity(CHF_AUTOIX[i],dimless2) =(velocity(CHF_AUTOIX[i],dimless2)/this_vparnorm)
     &         - vparcomp*gradvn_dot_rdot
         endif

c        mu_dot

         velocity(CHF_AUTOIX[i],dimless1) = zero

         if (use_locnormalized_vels .EQ. 1) then
           gradmun_dot_rdot = zero
           do n = 0, dimless3
              gradmun_dot_rdot = gradmun_dot_rdot + this_gradlogmun(n)*velocity(CHF_AUTOIX[i],n)
           enddo
           velocity(CHF_AUTOIX[i],dimless1) =velocity(CHF_AUTOIX[i],dimless1) - mucomp*gradmun_dot_rdot
         endif

      CHF_ENDDO

      return
      end


      subroutine compute_bfield_velocity(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA[Bvec],
     &     CHF_FRA[velocity]
     &     )

c     local variables
      integer CHF_AUTODECL[i], kk, itor4vel, phys_comp(0:2), dimless1, dimless2, dimless3, n

      kk = CHF_LBOUND[Bvec;2]
      phys_comp(0) = 0
      phys_comp(1) = 6-CH_SPACEDIM
      phys_comp(2) = 2
      dimless1 = CH_SPACEDIM-1
      dimless2 = CH_SPACEDIM-2
      dimless3 = CH_SPACEDIM-3
      CHF_AUTOMULTIDO[gridbox;i]
#if CH_SPACEDIM==5
         kk = i2
#endif

        do n = 0, dimless3
           velocity(CHF_AUTOIX[i],n) = Bvec(CHF_IX[i0;i1;kk;CHF_LBOUND[Bvec;3];CHF_LBOUND[Bvec;4]],phys_comp(n))
        enddo

        do n=dimless2, dimless1
           velocity(CHF_AUTOIX[i],n) = zero
        enddo

      CHF_ENDDO

      return
      end



      subroutine annulus_polvel_test(
     &     CHF_CONST_INT[dir],
     &     CHF_BOX[gridbox],
     &     CHF_CONST_REALVECT[h],
     &     CHF_CONST_REAL[rmin],
     &     CHF_CONST_REAL[rbar],
     &     CHF_CONST_REAL[R0],
     &     CHF_FRA[velocity],
     &     CHF_INT[l_const_minorrad]
     &     )

c     local variables
      double precision r, theta,Rmaj,costheta,radfac
      integer CHF_AUTODECL[i], m

c      print *, "R0, rbar = ", R0, rbar
      CHF_AUTOMULTIDO[gridbox;i]

         theta = ( i1 + half*(1-CHF_ID(1,dir)) )*h(1)
         costheta = dcos(theta)
         if (l_const_minorrad .eq. 1) then
             r = rbar
             Rmaj = R0
         else
             r     = ( i0 + half*(1-CHF_ID(0,dir)) )*h(0) + rmin
            Rmaj = R0 + r*costheta
         endif
         radfac = r*R0/(rbar*Rmaj)

         velocity(CHF_AUTOIX[i],0) = -radfac * dsin(theta)
         velocity(CHF_AUTOIX[i],1) =  radfac * costheta
c         velocity(CHF_AUTOIX[i],0) =  radfac * dsin(theta)
c         velocity(CHF_AUTOIX[i],1) = -radfac * costheta
         velocity(CHF_AUTOIX[i],2) = zero
         velocity(CHF_AUTOIX[i],3) = zero
#if CH_SPACEDIM==5
         velocity(CHF_AUTOIX[i],4) = zero
#endif

      CHF_ENDDO

      return
      end



      subroutine annulus_radvel_test(
     &     CHF_CONST_INT[dir],
     &     CHF_BOX[gridbox],
     &     CHF_CONST_REALVECT[h],
     &     CHF_CONST_REAL[rmin],
     &     CHF_CONST_REAL[rbar],
     &     CHF_CONST_REAL[R0],
     &     CHF_FRA[velocity],
     &     CHF_INT[l_const_minorrad]
     &     )

c     local variables
      double precision r, theta,Rmaj,costheta,radfac
      integer CHF_AUTODECL[i], m

      CHF_AUTOMULTIDO[gridbox;i]

         theta = ( i1 + half*(1-CHF_ID(1,dir)) )*h(1)
         costheta = dcos(theta)
         if (l_const_minorrad .eq. 1) then
             r = rbar
             Rmaj = R0
         else
             r     = ( i0 + half*(1-CHF_ID(0,dir)) )*h(0) + rmin
            Rmaj = R0 + r*costheta
         endif
         radfac = (rbar*R0)/r*Rmaj

         velocity(CHF_AUTOIX[i],0) = costheta*radfac
         velocity(CHF_AUTOIX[i],1) = dsin(theta)*radfac
         velocity(CHF_AUTOIX[i],2) = zero
         velocity(CHF_AUTOIX[i],3) = zero
#if CH_SPACEDIM==5
         velocity(CHF_AUTOIX[i],4) = zero
#endif

      CHF_ENDDO

      return
      end



      subroutine annulus_radpolvel_test(
     &     CHF_CONST_INT[dir],
     &     CHF_BOX[gridbox],
     &     CHF_CONST_REALVECT[h],
     &     CHF_CONST_REAL[rmin],
     &     CHF_CONST_REAL[rbar],
     &     CHF_CONST_REAL[R0],
     &     CHF_FRA[velocity],
     &     CHF_INT[l_const_minorrad]
     &     )

c     local variables
      double precision r, theta,delta_r,polvelmult,radfac,sintheta,costheta
      double precision Rmaj,radfac1
      integer CHF_AUTODECL[i], m, imax

c     rescale poloidal velocity to advance thru domain at same rate as radial
c     To do this: the radial velocity remains as 1; multiply the poloidal by
c     2 pi/delta_r, where delta_r = rmax - rmin

      imax = CHF_UBOUND[gridbox;0]
      delta_r = ( imax+half*(1-CHF_ID(0,dir)))*h(0)
      polvelmult = 2.*3.14159/delta_r

      CHF_AUTOMULTIDO[gridbox;i]

         r     = ( i0 + half*(1-CHF_ID(0,dir)) )*h(0) + rmin
         theta = ( i1 + half*(1-CHF_ID(1,dir)) )*h(1)
         costheta = dcos(theta)
         sintheta = dsin(theta)
         if (l_const_minorrad .eq. 1) then
             r = rbar
             Rmaj = R0
         else
             r     = ( i0 + half*(1-CHF_ID(0,dir)) )*h(0) + rmin
            Rmaj = R0 + r*costheta
         endif
         radfac = (rbar*R0)/r*Rmaj
         radfac1 = r*R0/(rbar*Rmaj)

         velocity(CHF_AUTOIX[i],0) = -radfac1*polvelmult*sintheta + costheta*radfac
         velocity(CHF_AUTOIX[i],1) =  radfac1*polvelmult*costheta + sintheta*radfac
         velocity(CHF_AUTOIX[i],2) = zero
         velocity(CHF_AUTOIX[i],3) = zero
#if CH_SPACEDIM==5
         velocity(CHF_AUTOIX[i],4) = zero
#endif

      CHF_ENDDO

      return
      end



      subroutine major_radial_vel_test(
     &     CHF_CONST_INT[dir],
     &     CHF_BOX[gridbox],
     &     CHF_FRA[velocity]
     &     )

c     local variables
      integer CHF_AUTODECL[i]

      CHF_AUTOMULTIDO[gridbox;i]

         velocity(CHF_AUTOIX[i],0) = one
         velocity(CHF_AUTOIX[i],1) = zero
         velocity(CHF_AUTOIX[i],2) = zero
         velocity(CHF_AUTOIX[i],3) = zero
#if CH_SPACEDIM==5
         velocity(CHF_AUTOIX[i],4) = zero
#endif

      CHF_ENDDO

      return
      end



      subroutine free_stream_vel_test(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_REALVECT[component],
     &     CHF_CONST_FRA1[major_radius],
     &     CHF_CONST_INT[axisymmetric],
     &     CHF_FRA[velocity]
     &     )

c     local variables
      integer CHF_AUTODECL[i],n,kk
      kk = CHF_LBOUND[major_radius;2]

      CHF_AUTOMULTIDO[gridbox;i]
         do n = 0, CHF_NCOMP[velocity]-1
           velocity(CHF_AUTOIX[i],n) = component(n)
         enddo
      CHF_ENDDO

      if (axisymmetric .ne. 0) then
         CHF_AUTOMULTIDO[gridbox;i]
#if CH_SPACEDIM==5
            kk = i2
#endif
            velocity(CHF_AUTOIX[i],0) = velocity(CHF_AUTOIX[i],0)
     &         / major_radius(CHF_IX[i0;i1;kk;CHF_LBOUND[major_radius;3];CHF_LBOUND[major_radius;4]])
         CHF_ENDDO
      endif

      return
      end



      subroutine compute_bstar(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_REALVECT[h],
     &     CHF_CONST_REAL[prefactor],
     &     CHF_CONST_FRA[B],
     &     CHF_CONST_FRA1[B_magnitude],
     &     CHF_CONST_FRA[curlb],
     &     CHF_CONST_FRA1[bdotcurlb],
     &     CHF_FRA[BStar],
     &     CHF_FRA1[BStarPar],
     &     CHF_CONST_INT[use_locnormalized_vels],
     &     CHF_CONST_FRA[vnorm],
     &     )

c     local variables
      integer CHF_AUTODECL[i], m, kk, indvpar, kkv
      double precision v_par_avg, dv_parallel

      kk = CHF_LBOUND[B;2]
      if (use_locnormalized_vels .eq. 1) then
         kkv = CHF_LBOUND[vnorm;2]
      endif
      dv_parallel = h(CH_SPACEDIM-2)

      CHF_AUTOMULTIDO[gridbox;i]
         indvpar = i2
#if CH_SPACEDIM==5
         kk = i2
         kkv = i2
         indvpar = i3
#endif
         v_par_avg = (indvpar + half)*dv_parallel
         if (use_locnormalized_vels .EQ. 1) then
            v_par_avg = v_par_avg*vnorm(CHF_IX[i0;i1;kkv;CHF_LBOUND[vnorm;3];CHF_LBOUND[vnorm;4]],0)
         endif
         do m = 0, 2
            BStar(CHF_AUTOIX[i],m) = B(CHF_IX[i0;i1;kk;CHF_LBOUND[B;3];CHF_LBOUND[B;4]],m)
     &           + prefactor * v_par_avg * curlb(CHF_IX[i0;i1;kk;CHF_LBOUND[curlb;3];CHF_LBOUND[curlb;4]],m)
         enddo

         BStarPar(CHF_AUTOIX[i]) = B_magnitude(CHF_IX[i0;i1;kk;CHF_LBOUND[B_magnitude;3];CHF_LBOUND[B_magnitude;4]])
     &           + prefactor * v_par_avg * bdotcurlb(CHF_IX[i0;i1;kk;CHF_LBOUND[bdotcurlb;3];CHF_LBOUND[bdotcurlb;4]])

      CHF_ENDDO

      return
      end



c --------------------------------------------------------------
c  this subroutine computes the pointwise dot product of A
c  (from astart.. astart+SpaceDim-1 )
c  and B (from bstart..bstart+SpaceDim-1)
c  and places the result in c.
c
c  INPUTS/OUTPUTS:
c  c  <=  pointwise dot product of a and b
c  a   =>
c  astart => component of a at which to start
c  b   =>
c  bstart => component of b at which to start
c  gridbox => box over which to operate
c --------------------------------------------------------------
      subroutine pscspointdotprodcfg(CHF_FRA1[c],
     &                        CHF_CONST_FRA[a],
     &                        CHF_CONST_INT[astart],
     &                        CHF_CONST_FRA[b],
     &                        CHF_CONST_INT[bstart],
     &                        CHF_CONST_INT[ncomp],
     &                        CHF_BOX[gridbox])

      integer CHF_DDECL[i;j;k;l;m;n], kk
      integer comp, na, nb

      CHF_MULTIDO[gridbox;i;j;k;l;m;n]
         c(CHF_IX[i;j;k;l;m;n]) = zero
      CHF_ENDDO

      kk = CHF_LBOUND[b;2]

      do comp=0, ncomp-1
         na = astart+comp
         nb = bstart+comp
         CHF_MULTIDO[gridbox;i;j;k;l;m;n]

#if CH_SPACEDIM==5
           kk = k
#endif
           c(CHF_IX[i;j;k;l;m;n]) = c(CHF_IX[i;j;k;l;m;n])
     &     +a(CHF_IX[i;j;k;l;m;n],na)*b(CHF_IX[i;j;kk;CHF_LBOUND[b;3];CHF_LBOUND[b;4]],nb)
         CHF_ENDDO
      enddo

      return
      end



c --------------------------------------------------------------
c  this subroutine computes the pointwise dot product of A
c  (from astart.. astart+SpaceDim-1 )
c  and B (from bstart..bstart+SpaceDim-1)
c  and places the result in c.
c
c  INPUTS/OUTPUTS:
c  c  <=  pointwise dot product of a and b
c  a   =>
c  astart => component of a at which to start
c  b   =>
c  bstart => component of b at which to start
c  gridbox => box over which to operate
c --------------------------------------------------------------
      subroutine pscspointdotprodvel(CHF_FRA1[c],
     &                        CHF_CONST_FRA[a],
     &                        CHF_CONST_INT[astart],
     &                        CHF_CONST_FRA[b],
     &                        CHF_CONST_INT[bstart],
     &                        CHF_CONST_INT[ncomp],
     &                        CHF_BOX[gridbox])

      integer CHF_DDECL[i;j;k;l;m;n], kk
      integer comp, na, nb

      CHF_MULTIDO[gridbox;i;j;k;l;m;n]
         c(CHF_IX[i;j;k;l;m;n]) = zero
      CHF_ENDDO

      do comp=0, ncomp-1
         na = astart+comp
         nb = bstart+comp
         CHF_MULTIDO[gridbox;i;j;k;l;m;n]
          kk = k
#if CH_SPACEDIM==5
          kk = CHF_LBOUND[b;2]
#endif
          c(CHF_IX[i;j;k;l;m;n]) = c(CHF_IX[i;j;k;l;m;n])
     &     +a(CHF_IX[i;j;k;l;m;n],na)*b(CHF_IX[CHF_LBOUND[b;0];CHF_LBOUND[b;1];kk;l;m;n],nb)
         CHF_ENDDO
      enddo

      return
      end



c  -----------------------------------------------------------
c    pointwise reduced-dimensional dot product
c  -----------------------------------------------------------
      subroutine pscspointwisereduceddotprodcfg(CHF_FRA1[c],
     &                                   CHF_CONST_FRA[a],
     &                                   CHF_CONST_INT[astart],
     &                                   CHF_CONST_FRA[b],
     &                                   CHF_CONST_INT[bstart],
     &                                   CHF_CONST_INT[numcomp],
     &                                   CHF_BOX[gridbox])


      integer CHF_DDECL[i;j;k;l;m;n], kk
      integer comp, na, nb
      
      kk = CHF_LBOUND[a;2]

      CHF_MULTIDO[gridbox;i;j;k;l;m;n]
         c(CHF_IX[i;j;k;l;m;n]) = zero
      CHF_ENDDO

      do comp=0, numcomp-1
         na = comp + astart;
         nb = comp + bstart;
         CHF_MULTIDO[gridbox;i;j;k;l;m;n]
#if CH_SPACEDIM==5
           kk = k
#endif
           c(CHF_IX[i;j;k;l;m;n]) = c(CHF_IX[i;j;k;l;m;n])
     &  +a(CHF_IX[i;j;kk;CHF_LBOUND[a;3];CHF_LBOUND[a;4]],na)*b(CHF_IX[i;j;k;l;m;n],nb)
         CHF_ENDDO
      enddo

      return
      end



      subroutine pscspointwisereduceddotprodvel(CHF_FRA1[c],
     &                                   CHF_CONST_FRA[a],
     &                                   CHF_CONST_INT[astart],
     &                                   CHF_CONST_FRA[b],
     &                                   CHF_CONST_INT[bstart],
     &                                   CHF_CONST_INT[numcomp],
     &                                   CHF_BOX[gridbox])

      integer CHF_DDECL[i;j;k;l;m;n], kk
      integer comp, na, nb

      CHF_MULTIDO[gridbox;i;j;k;l;m;n]
         c(CHF_IX[i;j;k;l;m;n]) = zero
      CHF_ENDDO

      do comp=0, numcomp-1
         na = comp + astart;
         nb = comp + bstart;
         CHF_MULTIDO[gridbox;i;j;k;l;m;n]
          kk = k
#if CH_SPACEDIM==5
          kk = CHF_LBOUND[a;2]
#endif
           c(CHF_IX[i;j;k;l;m;n]) = c(CHF_IX[i;j;k;l;m;n])
     &  +a(CHF_IX[CHF_LBOUND[a;0];CHF_LBOUND[a;1];kk;l;m;n],na)*b(CHF_IX[i;j;k;l;m;n],nb)
         CHF_ENDDO
      enddo

      return
      end



      subroutine pscstangradface(CHF_FRA1[gradPhi],
     &     CHF_CONST_FRA1[phi],
     &     CHF_BOX[gradBox],
     &     CHF_INT[gradDir],
     &     CHF_CONST_REAL[dx])

      integer CHF_DDECL[i;j;k;l;m;n]
      integer CHF_DDECL[ii;jj;kk;ll;mm;nn]
      REAL_T halfOnDx

      halfOnDx = half/dx

      CHF_DTERM[ii = CHF_ID(0,gradDir);
                jj = CHF_ID(1,gradDir);
                kk = CHF_ID(2,gradDir);
                ll = CHF_ID(3,gradDir);
                mm = CHF_ID(4,gradDir);
                nn = CHF_ID(5,gradDir);
                ]

      CHF_MULTIDO[gradBox; i;j;k;l;m;n]
      gradPhi(CHF_IX[i;j;k;l;m;n]) = halfOnDx*(phi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm;n+nn])
     &                                    -phi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm;n-nn]))

      CHF_ENDDO

      return
      end

c -------------------------------------------------------
c  this subroutine computes the cell-averaged divergence
c  from the face-averaged flux field. Or, of fluxes are
c  face-centered, then computes cell-centered divergence.
c  Flux field is assumed to already contain metric/Jacobian
c  values.
c
c  INPUTS/OUTPUTS:
c  Flux   => Face-averaged(centered) field in dir direction
c  div    <=  cell-averaged(centered) div(Flux)
c  gridInt => box which defines interior of grid
c  dx      => cell spacing in direction dir
c  dir     => direction
c -------------------------------------------------------
      subroutine fluxnormaldivergence(CHF_CONST_FRA[Flux],
     &                                CHF_FRA[div],
     &                                CHF_BOX[gridInt],
     &                                CHF_CONST_REALVECT[dx],
     &                                CHF_INT[dir])

c ::: local variables
      integer CHF_DDECL[i;j;k;l;m;n]
      integer CHF_DDECL[ii;jj;kk;ll;mm;nn]
      integer comp

      do comp=0,CHF_NCOMP[div]-1

      CHF_MULTIDO[gridInt;i;j;k;l;m;n]

      CHF_DTERM[
      ii = i+CHF_ID(0,dir);
      jj = j+CHF_ID(1,dir);
      kk = k+CHF_ID(2,dir);
      ll = l+CHF_ID(3,dir);
      mm = m+CHF_ID(4,dir);
      nn = n+CHF_ID(5,dir)]

      div(CHF_IX[i;j;k;l;m;n],comp) = div(CHF_IX[i;j;k;l;m;n],comp)
     &                              + ( Flux(CHF_IX[ii;jj;kk;ll;mm;nn],comp)
     &                              -   Flux(CHF_IX[i;j;k;l;m;n],comp) )/dx(dir)

      CHF_ENDDO

      enddo

      return
      end


c -------------------------------------------------------
c  this subroutine computes the cell-centered divergence
c  from the edge centered velocity field -- does this in
c  a direction-by-direction basis; increments div with
c  du/dx or dv/dy or dw/dz. actually assumes that dx=dy=dz
c
c  INPUTS/OUTPUTS:
c  uEdge   => edge-centered vector field in direction dir
c  div    <=  cell-centered divergence
c  gridInt => box which defines interior of grid
c  dx      => cell spacing in direction dir
c  dir     => coordinate direction
c -------------------------------------------------------
      subroutine pscsdivergence(CHF_CONST_FRA[uEdge],
     &                          CHF_FRA[div],
     &                          CHF_BOX[gridInt],
     &                          CHF_CONST_REAL[dx],
     &                          CHF_INT[dir])

c ::: local variables
      integer CHF_DDECL[i;j;k;l;m;n]
      integer CHF_DDECL[ii;jj;kk;ll;mm;nn]
      integer comp
      REAL_T one_on_dx

      one_on_dx = one/dx

      do comp=0,CHF_NCOMP[div]-1

      CHF_MULTIDO[gridInt;i;j;k;l;m;n]
      CHF_DTERM[
      ii = i+CHF_ID(0,dir);
      jj = j+CHF_ID(1,dir);
      kk = k+CHF_ID(2,dir);
      ll = l+CHF_ID(3,dir);
      mm = m+CHF_ID(4,dir);
      nn = n+CHF_ID(5,dir)]

      div(CHF_IX[i;j;k;l;m;n],comp) = div(CHF_IX[i;j;k;l;m;n],comp)
     &                      +one_on_dx*(uEdge(CHF_IX[ii;jj;kk;ll;mm;nn],comp)
     &                                 -uEdge(CHF_IX[i;j;k;l;m;n],comp))

      CHF_ENDDO

      enddo

      return
      end



      subroutine mult_cfg_nt(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA[N],
     &     CHF_FRA[velocity]
     &     )

c     local variables
      double precision NT11, NT12, NT13, NT21, NT22, NT23, NT31, NT32, NT33, v0, v1, v2
      integer CHF_AUTODECL[i], kk, k12, k21, k22
      kk = CHF_LBOUND[N;2]
      k12 = 2
      k22 = 3
#if CH_SPACEDIM==5
       k12 = 3
       k22 = 4
#endif

      CHF_AUTOMULTIDO[gridbox;i]
#if CH_SPACEDIM==5
         kk = i2
#endif

         NT11 = N(CHF_IX[i0;i1;kk;CHF_LBOUND[N;3];CHF_LBOUND[N;4]],0)
         NT12 = N(CHF_IX[i0;i1;kk;CHF_LBOUND[N;3];CHF_LBOUND[N;4]],k12)
         NT21 = N(CHF_IX[i0;i1;kk;CHF_LBOUND[N;3];CHF_LBOUND[N;4]],1)
         NT22 = N(CHF_IX[i0;i1;kk;CHF_LBOUND[N;3];CHF_LBOUND[N;4]],k22)
#if CH_SPACEDIM==5
         NT13 = N(CHF_IX[i0;i1;kk;CHF_LBOUND[N;3];CHF_LBOUND[N;4]],6)
         NT23 = N(CHF_IX[i0;i1;kk;CHF_LBOUND[N;3];CHF_LBOUND[N;4]],7)
         NT31 = N(CHF_IX[i0;i1;kk;CHF_LBOUND[N;3];CHF_LBOUND[N;4]],2)
         NT32 = N(CHF_IX[i0;i1;kk;CHF_LBOUND[N;3];CHF_LBOUND[N;4]],5)
         NT33 = N(CHF_IX[i0;i1;kk;CHF_LBOUND[N;3];CHF_LBOUND[N;4]],8)
#endif

         v0 = NT11 * velocity(CHF_AUTOIX[i],0) + NT12 * velocity(CHF_AUTOIX[i],1)
         v1 = NT21 * velocity(CHF_AUTOIX[i],0) + NT22 * velocity(CHF_AUTOIX[i],1)
#if CH_SPACEDIM==5
         v0 = v0 + NT13*velocity(CHF_AUTOIX[i],2)
         v1 = v1 + NT23*velocity(CHF_AUTOIX[i],2)
         v2 = NT31 * velocity(CHF_AUTOIX[i],0) + NT32 * velocity(CHF_AUTOIX[i],1)
     &            + NT33 * velocity(CHF_AUTOIX[i],2)
#endif


         velocity(CHF_AUTOIX[i],0) = v0
         velocity(CHF_AUTOIX[i],1) = v1
#if CH_SPACEDIM==5
         velocity(CHF_AUTOIX[i],2) = v2
#endif

      CHF_ENDDO

      return
      end



      subroutine mult_vel_nt(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA1[TwoPirRmaj],
     &     CHF_FRA[velocity]
     &     )

c     local variables
      integer CHF_AUTODECL[i], dir, kk
      kk = CHF_LBOUND[TwoPirRmaj;2]

      CHF_AUTOMULTIDO[gridbox;i]
#if CH_SPACEDIM==5
         kk = i2
#endif
         do dir = CH_SPACEDIM-2, CH_SPACEDIM-1
            velocity(CHF_AUTOIX[i],dir) = velocity(CHF_AUTOIX[i],dir)
     &           * TwoPirRmaj(CHF_IX[i0;i1;kk;CHF_LBOUND[TwoPirRmaj;3];CHF_LBOUND[TwoPirRmaj;4]])
         enddo
      CHF_ENDDO

      return
      end



      subroutine mult_cfg(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA1[factor],
     &     CHF_FRA[data])

c   Multiplies a directional array (vector)  "data", dependent on all  phase-space variables,
c   by the scalar array "factor" evaluated at the lowest index in the velocity coordinates (useful for
c   the case where "factor" is a configuration-space dependent  scalar projected into phase space).

c     local variables
      integer CHF_AUTODECL[i], comp, kk
      kk = CHF_LBOUND[factor;2]

      do comp = 0, CHF_NCOMP[data]-1
         CHF_AUTOMULTIDO[gridBox; i]
#if CH_SPACEDIM==5
            kk = i2
#endif
            data(CHF_AUTOIX[i],comp) = data(CHF_AUTOIX[i],comp)
     &        * factor(CHF_IX[i0;i1;kk;CHF_LBOUND[factor;3];CHF_LBOUND[factor;4]])
         CHF_ENDDO
      enddo

      return
      end



      subroutine mult_vel(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA1[factor],
     &     CHF_FRA[data])

c   Multiplies a directional array (vector)  "data", dependent on all  phase-space variables,
c   by the scalar array "factor" evaluated at the lowest index in the configuration coordinates (useful for
c   the case where "factor" is a velocity-space dependent  scalar projected into phase space).

c     local variables
      integer CHF_AUTODECL[i], comp, kk

      do comp = 0, CHF_NCOMP[data]-1
         CHF_AUTOMULTIDO[gridBox;i]
            kk = i2
#if CH_SPACEDIM==5
            kk = CHF_LBOUND[factor;2]
#endif
            data(CHF_AUTOIX[i],comp) = data(CHF_AUTOIX[i],comp)
     &        * factor(CHF_IX[CHF_LBOUND[factor;0];CHF_LBOUND[factor;1];kk;i3;i4;i5])
         CHF_ENDDO
      enddo

      return
      end


      subroutine mult_radial_component(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA1[factor],
     &     CHF_FRA1[data])

c   Multiplies a scalar array "data", dependent on all  phase-space variables,
c   by the scalar array "factor" evaluated at the lowest index in the velocity coordinates (useful for
c   the case where "factor" is a configuration-space dependent  scalar projected into phase space).

c     local variables
      integer CHF_AUTODECL[i],kk
      kk = CHF_LBOUND[factor;2]
      CHF_AUTOMULTIDO[gridBox;i]
#if CH_SPACEDIM==5
         kk = i2
#endif
         data(CHF_AUTOIX[i]) = data(CHF_AUTOIX[i])
     &        * factor(CHF_IX[i0;i1;kk;CHF_LBOUND[factor;3];CHF_LBOUND[factor;4]])
      CHF_ENDDO

      return
      end

      subroutine compute_Q0X(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA[integrals],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_REAL[charge],
     &     CHF_CONST_REAL[larmor],
     &     CHF_CONST_INT[include_ExB_drift],
     &     CHF_CONST_INT[include_magnetic_drift],
     &     CHF_FRA1[Q])

c     local variables
      integer CHF_DDECL[i;j;k;l;m;n], comp, kk
      double precision eta(0:1), vpar, mu_lo, mu_hi, mu_integral0, mu_integral1, sum

      kk = CHF_LBOUND[integrals;2]
      CHF_MULTIDO[gridBox; i;j;k;l;m;n]
#if CH_SPACEDIM==5
         kk = k
         vpar = l * dx(3)
         mu_lo = m * dx(4)
         mu_hi = mu_lo + dx(4)
         mu_integral0 = dx(4)
         mu_integral1 = half * (mu_hi**2 - mu_lo**2)
#else
         vpar = k * dx(2)
         mu_lo = l * dx(3)
         mu_hi = mu_lo + dx(3)
         mu_integral0 = dx(3)
         mu_integral1 = half * (mu_hi**2 - mu_lo**2)
#endif

         if (include_ExB_drift .ne. 0) then
            eta(0) = mu_integral0
         else
            eta(0) = zero
         endif            

         if (include_magnetic_drift .ne. 0) then
            eta(1) = half * mu_integral1 / charge
         else
            eta(1) = zero
         endif

         sum = zero
         do comp = 0, 1
            sum = sum + eta(comp) * integrals(CHF_IX[i;j;kk;CHF_LBOUND[integrals;3];CHF_LBOUND[integrals;4]], comp)
         enddo

         Q(CHF_IX[i;j;k;l;m;n]) = vpar * larmor * sum

      CHF_ENDDO

      return
      end

      subroutine compute_Q12(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_INT[side],
     &     CHF_CONST_FRA[nodal_integrals],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_REAL[mass],
     &     CHF_CONST_REAL[charge],
     &     CHF_CONST_REAL[larmor],
     &     CHF_CONST_INT[no_par_stream],
     &     CHF_CONST_INT[include_magnetic_drift],
     &     CHF_FRA1[Q])

c     local variables
      integer CHF_DDECL[i;j;k;l;m;n], CHF_DDECL[ii;jj;kk;ll;mm;nn], tdir, comp, k_fix, k_kk_fix
      double precision eta(0:1), vpar_lo, vpar_hi, sum

      tdir = 1 - dir

      CHF_DTERM[ii = CHF_ID(0,tdir);
                jj = CHF_ID(1,tdir);
                kk = CHF_ID(2,tdir);
                ll = CHF_ID(3,tdir);
                mm = CHF_ID(4,tdir);
                nn = CHF_ID(5,tdir);
      ]

      k_fix = CHF_LBOUND[nodal_integrals;2]
      k_kk_fix = CHF_LBOUND[nodal_integrals;2]
      CHF_MULTIDO[gridBox; i;j;k;l;m;n]
#if CH_SPACEDIM==5
         k_fix = k
         k_kk_fix = k + kk
         vpar_lo = l * dx(3)
         vpar_hi = vpar_lo + dx(3)
#else
         vpar_lo = k * dx(2)
         vpar_hi = vpar_lo + dx(2)
#endif


         if (no_par_stream .ne. 0) then
            eta(0) = zero
         else
            eta(0) = half * (vpar_hi**2 - vpar_lo**2)
         endif

         if (include_magnetic_drift .ne. 0) then
            eta(1) = third * (vpar_hi**3 - vpar_lo**3) * mass * larmor / charge
         else
            eta(1) = zero
         endif
         
         if (side .eq. 0) then
            sum = zero
            do comp = 0, 1
               sum = sum + eta(comp) * nodal_integrals(CHF_IX[i;j;k_fix;CHF_LBOUND[nodal_integrals;3];CHF_LBOUND[nodal_integrals;4]], comp)
            enddo
         else
            sum = zero
            do comp = 0, 1
               sum = sum + eta(comp) * nodal_integrals(CHF_IX[i+ii;j+jj;k_kk_fix;CHF_LBOUND[nodal_integrals;3];CHF_LBOUND[nodal_integrals;4]], comp)
            enddo
         endif

#if CH_SPACEDIM==5
         Q(CHF_IX[i;j;k;l;m;n]) = dx(4) * sum
#else
         Q(CHF_IX[i;j;k;l;m;n]) = dx(3) * sum
#endif

      CHF_ENDDO

      return
      end

      subroutine compute_uhat(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA[integrals],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_REAL[mass],
     &     CHF_CONST_REAL[charge],
     &     CHF_CONST_INT[no_zero_order_par],
     &     CHF_FRA1[uhat])

c     local variables
      integer CHF_DDECL[i;j;k;l;m;n], comp, kk
      double precision mu_lo, mu_hi, mu_integral0, mu_integral1, cfg_area

      kk = CHF_LBOUND[integrals;2]
      CHF_MULTIDO[gridBox; i;j;k;l;m;n]
#if CH_SPACEDIM==5
         kk = k
         mu_lo = m * dx(4)
         mu_hi = mu_lo + dx(4)
         mu_integral0 = dx(4)
#else
         mu_lo = l * dx(3)
         mu_hi = mu_lo + dx(3)
         mu_integral0 = dx(3)
#endif

         if (no_zero_order_par .ne. 0) then
           mu_integral1 = 0.0
         else 
           mu_integral1 = half * (mu_hi**2 - mu_lo**2)
         endif

         uhat(CHF_IX[i;j;k;l;m;n]) 
     &        = (mu_integral0 * charge * integrals(CHF_IX[i;j;kk;CHF_LBOUND[integrals;3];CHF_LBOUND[integrals;4]],0) 
     &        +  half * mu_integral1 * integrals(CHF_IX[i;j;kk;CHF_LBOUND[integrals;3];CHF_LBOUND[integrals;4]],1) ) / mass
      CHF_ENDDO

      return
      end


      subroutine compute_radial_projection(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[bunit],
     &     CHF_CONST_FRA[vector],
     &     CHF_CONST_FRA1[vector_r]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k;l;m] 
      double precision fac

      CHF_MULTIDO[box;i;j;k;l;m]

#if CH_SPACEDIM==4

         fac = sqrt(bunit(i,j,CHF_LBOUND[bunit;2],CHF_LBOUND[bunit;3],0) ** 2
     &             +bunit(i,j,CHF_LBOUND[bunit;2],CHF_LBOUND[bunit;3],2) ** 2)                

         vector_r(CHF_IX[i;j;k;l;m]) = vector(CHF_IX[i;j;k;l;m],0) * bunit(i,j,CHF_LBOUND[bunit;2],CHF_LBOUND[bunit;3],2)/fac
     &                               - vector(CHF_IX[i;j;k;l;m],1) * bunit(i,j,CHF_LBOUND[bunit;2],CHF_LBOUND[bunit;3],0)/fac 


#else

         fac = sqrt(bunit(i,j,k,CHF_LBOUND[bunit;3],CHF_LBOUND[bunit;4],0) ** 2
     &             +bunit(i,j,k,CHF_LBOUND[bunit;3],CHF_LBOUND[bunit;4],2) ** 2)                

         vector_r(CHF_IX[i;j;k;l;m]) = vector(CHF_IX[i;j;k;l;m],0) * bunit(i,j,k,CHF_LBOUND[bunit;3],CHF_LBOUND[bunit;4],2)/fac
     &                               - vector(CHF_IX[i;j;k;l;m],2) * bunit(i,j,k,CHF_LBOUND[bunit;3],CHF_LBOUND[bunit;4],0)/fac 

#endif
   
      CHF_ENDDO

      return
      end


      subroutine compute_poloidal_projection(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[bunit],
     &     CHF_CONST_FRA[vector],
     &     CHF_CONST_FRA1[vector_pol]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k;l;m] 
      double precision fac

      CHF_MULTIDO[box;i;j;k;l;m]

#if CH_SPACEDIM==4

         fac = sqrt(bunit(i,j,CHF_LBOUND[bunit;2],CHF_LBOUND[bunit;3],0) ** 2
     &             +bunit(i,j,CHF_LBOUND[bunit;2],CHF_LBOUND[bunit;3],2) ** 2)                

         vector_pol(CHF_IX[i;j;k;l;m]) = vector(CHF_IX[i;j;k;l;m],0) * bunit(i,j,CHF_LBOUND[bunit;2],CHF_LBOUND[bunit;3],0)/fac
     &                                 + vector(CHF_IX[i;j;k;l;m],1) * bunit(i,j,CHF_LBOUND[bunit;2],CHF_LBOUND[bunit;3],2)/fac 


#else

         fac = sqrt(bunit(i,j,k,CHF_LBOUND[bunit;3],CHF_LBOUND[bunit;4],0) ** 2
     &             +bunit(i,j,k,CHF_LBOUND[bunit;3],CHF_LBOUND[bunit;4],2) ** 2)                

         vector_pol(CHF_IX[i;j;k;l;m]) = vector(CHF_IX[i;j;k;l;m],0) * bunit(i,j,k,CHF_LBOUND[bunit;3],CHF_LBOUND[bunit;4],0)/fac
     &                                 + vector(CHF_IX[i;j;k;l;m],2) * bunit(i,j,k,CHF_LBOUND[bunit;3],CHF_LBOUND[bunit;4],2)/fac 


#endif
   
      CHF_ENDDO

      return
      end

      subroutine mult_njinverse(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[grad_var_mapped],
     &     CHF_CONST_FRA[njinverse],
     &     CHF_FRA[grad_var],
     &     CHF_CONST_INT[cfg_dim],
     &     CHF_CONST_INT[max_dim]
     &     )

c     local variables
      integer CHF_AUTODECL[i]
      integer p, row, col
      double precision sum

      CHF_AUTOMULTIDO[box;i]

         p = 0
         do row = 0, cfg_dim-1
            sum = zero
            do col = 0, cfg_dim-1
#if CH_SPACEDIM==4
               sum = sum 
     &                + njinverse(i0,i1,CHF_LBOUND[njinverse;2],CHF_LBOUND[njinverse;3],p) 
     &                * grad_var_mapped(CHF_AUTOIX[i],col)
#else
               sum = sum 
     &                + njinverse(i0,i1,i2,CHF_LBOUND[njinverse;3],CHF_LBOUND[njinverse;4],p) 
     &                * grad_var_mapped(CHF_AUTOIX[i],col)
#endif
               p = p + 1
            enddo
            grad_var(CHF_AUTOIX[i],row) = sum
         enddo

         if (max_dim .EQ. CH_SPACEDIM) then
           do row = cfg_dim, CH_SPACEDIM-1
              grad_var(CHF_AUTOIX[i],row) = grad_var_mapped(CHF_AUTOIX[i],row)
           enddo
         endif

      CHF_ENDDO

      return
      end
