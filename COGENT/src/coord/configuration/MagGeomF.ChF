      subroutine mult_njinverse(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[efield_mapped],
     &     CHF_CONST_FRA[njinverse],
     &     CHF_FRA[efield]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k], m, row, col
      double precision sum

      CHF_MULTIDO[box;i;j;k]

         m = 0
         do row = 0, CH_SPACEDIM-1
            sum = zero
            do col = 0, CH_SPACEDIM-1
               sum = sum + njinverse(CHF_IX[i;j;k],m) * efield_mapped(CHF_IX[i;j;k],col)
               m = m + 1
            enddo
            efield(CHF_IX[i;j;k],row) = sum
         enddo

      CHF_ENDDO

      return
      end

      subroutine project_onto_parallel(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[bunit],
     &     CHF_FRA[vector]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k],n
      double precision fac

      fac = 0  
      CHF_MULTIDO[box;i;j;k]

#if CH_SPACEDIM==3

        do n = 0, CHF_NCOMP[vector]-1
         fac = fac + vector(CHF_IX[i;j;k],n) * bunit(CHF_IX[i;j;k],n) 
        enddo

        do n = 0, CHF_NCOMP[vector]-1
          vector(CHF_IX[i;j;k],n) = fac * bunit(CHF_IX[i;j;k],n) 
        enddo

#else
         fac = vector(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],0) 
     &       + vector(CHF_IX[i;j;k],1) * bunit(CHF_IX[i;j;k],2)                


          vector(CHF_IX[i;j;k],0) = fac * bunit(CHF_IX[i;j;k],0) 
          vector(CHF_IX[i;j;k],1) = fac * bunit(CHF_IX[i;j;k],2)       
   
#endif
      
      CHF_ENDDO

      return
      end

      subroutine compute_radial_projection(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[bunit],
     &     CHF_CONST_FRA[vector],
     &     CHF_CONST_FRA1[vector_r]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k] 
      double precision fac

      CHF_MULTIDO[box;i;j;k]

         fac = sqrt(bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],0) 
     &             +bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],2))                
        
         if (CHF_NCOMP[vector]. eq. 2) then 

           vector_r(CHF_IX[i;j;k]) = vector(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],2)/fac
     &                             - vector(CHF_IX[i;j;k],1) * bunit(CHF_IX[i;j;k],0)/fac 
           
   
         else  

           vector_r(CHF_IX[i;j;k]) = vector(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],2)/fac
     &                             - vector(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],0)/fac 


         endif
      
      CHF_ENDDO
      
      return
      end


      subroutine compute_poloidal_projection(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[bunit],
     &     CHF_CONST_FRA[vector],
     &     CHF_CONST_FRA1[vector_pol]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k] 
      double precision fac

      CHF_MULTIDO[box;i;j;k]

         fac = sqrt(bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],0) 
     &             +bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],2))                
        
         if (CHF_NCOMP[vector]. eq. 2) then

           vector_pol(CHF_IX[i;j;k]) = vector(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],0)/fac
     &                               + vector(CHF_IX[i;j;k],1) * bunit(CHF_IX[i;j;k],2)/fac 
   
         else  

           vector_pol(CHF_IX[i;j;k]) = vector(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],0)/fac
     &                               + vector(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],2)/fac 

         endif
      
      CHF_ENDDO

      return
      end

      subroutine compute_face_Binverse_integrals(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_FRA1[B],
     &     CHF_FRA1[integral])
c     local variables
      integer CHF_DDECL[i;j;k]
      double precision area

      area = dx(1-dir)

      CHF_MULTIDO[box;i;j;k]
         integral(CHF_IX[i;j;k]) = area / B(CHF_IX[i;j;k])
      CHF_ENDDO

      return
      end

      subroutine compute_face_bXgradB_integrals(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_FRA1[B],
     &     CHF_FRA1[integral])
c     local variables
      integer CHF_DDECL[i;j;k], CHF_DDECL[ii;jj;kk], tdir

      tdir = 1 - dir

      CHF_DTERM[
      ii = CHF_ID(0,tdir);
      jj = CHF_ID(1,tdir);
      kk = CHF_ID(2,tdir)]

      CHF_MULTIDO[box;i;j;k]
         integral(CHF_IX[i;j;k]) = dlog(B(CHF_IX[i;j;k])/B(CHF_IX[i+ii;j+jj;k+kk]))
      CHF_ENDDO

      return
      end
      
      subroutine simple_curl(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir_j],
     &     CHF_CONST_INT[dir_k],
     &     CHF_CONST_REAL[dX_j],
     &     CHF_CONST_REAL[dX_k],
     &     CHF_CONST_FRA[Edge_j],
     &     CHF_CONST_FRA[Edge_k],
     &     CHF_FRA[Face_i])
c     local variables
      integer n, CHF_DDECL[i;j;k], CHF_DDECL[ii_j;jj_j;kk_j], CHF_DDECL[ii_k;jj_k;kk_k] 
      double precision djEk, dkEj

      CHF_DTERM[
      ii_j = CHF_ID(0,dir_j);
      jj_j = CHF_ID(1,dir_j);
      kk_j = CHF_ID(2,dir_j)]
      
      CHF_DTERM[
      ii_k = CHF_ID(0,dir_k);
      jj_k = CHF_ID(1,dir_k);
      kk_k = CHF_ID(2,dir_k)]

      do n=0, (CHF_NCOMP[Face_i]-1)
         
         CHF_MULTIDO[box;i;j;k]
      
            djEk = (Edge_k(CHF_IX[i+ii_j;j+jj_j;k+kk_j],n) - Edge_k(CHF_IX[i;j;k],n))/dX_j
            dkEj = (Edge_j(CHF_IX[i+ii_k;j+jj_k;k+kk_k],n) - Edge_j(CHF_IX[i;j;k],n))/dX_k
            Face_i(CHF_IX[i;j;k],n) = djEk - dkEj

         CHF_ENDDO

      enddo

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      
      subroutine simple_curl_virt(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_REAL[dXdir],
     &     CHF_CONST_FRA[Fy],
     &     CHF_FRA[Jdir])
c     local variables
      integer n, CHF_DDECL[i;j;k], CHF_DDECL[ii;jj;kk] 
      double precision val

      CHF_DTERM[
      ii = CHF_ID(0,0);
      jj = CHF_ID(1,0);
      kk = CHF_ID(2,0)]
      
      do n=0, (CHF_NCOMP[Fy]-1)
         
         CHF_MULTIDO[box;i;j;k]
     
            if(dir==1) then
               val = (Fy(CHF_IX[i;j;k],n) - Fy(CHF_IX[i-1;j;k],n))/dXdir
            else
               val = -(Fy(CHF_IX[i;j;k],n) - Fy(CHF_IX[i;j-1;k],n))/dXdir
            endif
            Jdir(CHF_IX[i;j;k],n) = val

         CHF_ENDDO

      enddo

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      
      subroutine simple_curl_virt_cc(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_REAL[dXdir],
     &     CHF_CONST_FRA1[Fy],
     &     CHF_FRA[Jcurl])
c     local variables
      integer n, CHF_DDECL[i;j;k], CHF_DDECL[ii;jj;kk] 
      double precision val

      CHF_DTERM[
      ii = CHF_ID(0,0);
      jj = CHF_ID(1,0);
      kk = CHF_ID(2,0)]
      
      CHF_MULTIDO[box;i;j;k]
     
         if(dir==1) then
            val =  (Fy(CHF_IX[i+1;j;k]) - Fy(CHF_IX[i-1;j;k]))/dXdir*half
         else
            val = -(Fy(CHF_IX[i;j+1;k]) - Fy(CHF_IX[i;j-1;k]))/dXdir*half
         endif
         Jcurl(CHF_IX[i;j;k],dir) = val

      CHF_ENDDO

      return
      end
  
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
   
      subroutine on_axis_curl_correction(
     &     CHF_BOX[box],
     &     CHF_CONST_REAL[dX],
     &     CHF_CONST_FRA1[Xphys],
     &     CHF_CONST_FRA1[B],
     &     CHF_FRA1[curlB])
c     local variables
      integer CHF_DDECL[i;j;k]

      CHF_MULTIDO[box;i;j;k]
     
         if(Xphys(CHF_IX[i;j;k])==0.0) then
            curlB(CHF_IX[i;j;k]) = 4.0*B(CHF_IX[i;j;k])/dX;
c            print*, "dX = ", dX 
c            print*, "i = ", i 
c            print*, "j = ", j 
         endif

c            print*, "shape(B) = ", shape(B)
c            print*, "Xphys(i,j)   = ", Xphys(CHF_IX[i;j;k])
c            print*, "B(i,j)   = ", B(CHF_IX[i;j;k])

      CHF_ENDDO

      return
      end
      

      subroutine phys_to_covar(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[dXdxi],
     &     CHF_CONST_FRA[dxidX],
     &     CHF_CONST_INT[inverse],
     &     CHF_FRA[F])
      
      integer CHF_DDECL[i;j;k] 
      double precision Fnew0, Fnew1, Fnew2
      double precision a0, a1, a2, a3, a4, a5, a6, a7, a8

      CHF_MULTIDO[box;i;j;k]
      
         if (CH_SPACEDIM==3) then

            if (inverse==0) then
               a0 = dXdxi(CHF_IX[i;j;k],0)
               a1 = dXdxi(CHF_IX[i;j;k],1)
               a2 = dXdxi(CHF_IX[i;j;k],2)
               a3 = dXdxi(CHF_IX[i;j;k],3)
               a4 = dXdxi(CHF_IX[i;j;k],4)
               a5 = dXdxi(CHF_IX[i;j;k],5)
               a6 = dXdxi(CHF_IX[i;j;k],6)
               a7 = dXdxi(CHF_IX[i;j;k],7)
               a8 = dXdxi(CHF_IX[i;j;k],8)
            else
               a0 = dxidX(CHF_IX[i;j;k],0)
               a1 = dxidX(CHF_IX[i;j;k],1)
               a2 = dxidX(CHF_IX[i;j;k],2)
               a3 = dxidX(CHF_IX[i;j;k],3)
               a4 = dxidX(CHF_IX[i;j;k],4)
               a5 = dxidX(CHF_IX[i;j;k],5)
               a6 = dxidX(CHF_IX[i;j;k],6)
               a7 = dxidX(CHF_IX[i;j;k],7)
               a8 = dXdxi(CHF_IX[i;j;k],8)
            endif
  
            Fnew0 = a0*F(CHF_IX[i;j;k],0) + a1*F(CHF_IX[i;j;k],1) + a2*F(CHF_IX[i;j;k],2)
            Fnew1 = a3*F(CHF_IX[i;j;k],0) + a4*F(CHF_IX[i;j;k],1) + a5*F(CHF_IX[i;j;k],2)
            Fnew2 = a6*F(CHF_IX[i;j;k],0) + a7*F(CHF_IX[i;j;k],1) + a8*F(CHF_IX[i;j;k],2)

            F(CHF_IX[i;j;k],0) = Fnew0
            F(CHF_IX[i;j;k],1) = Fnew1
            F(CHF_IX[i;j;k],2) = Fnew2

         else
            
            if (inverse==0) then
               a0 = dXdxi(CHF_IX[i;j;k],0)
               a1 = dXdxi(CHF_IX[i;j;k],1)
               a2 = dXdxi(CHF_IX[i;j;k],2)
               a3 = dXdxi(CHF_IX[i;j;k],3)
            else
               a0 = dxidX(CHF_IX[i;j;k],0)
               a1 = dxidX(CHF_IX[i;j;k],1)
               a2 = dxidX(CHF_IX[i;j;k],2)
               a3 = dxidX(CHF_IX[i;j;k],3)
            endif
 
            Fnew0 = a0*F(CHF_IX[i;j;k],0) + a1*F(CHF_IX[i;j;k],1)
            Fnew1 = a2*F(CHF_IX[i;j;k],0) + a3*F(CHF_IX[i;j;k],1)

            F(CHF_IX[i;j;k],0) = Fnew0
            F(CHF_IX[i;j;k],1) = Fnew1

         endif

      CHF_ENDDO

      return
      end

      
      subroutine phys_to_contravar(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[dXdxi],
     &     CHF_CONST_FRA[dxidX],
     &     CHF_CONST_INT[inverse],
     &     CHF_FRA[F])
      
      integer CHF_DDECL[i;j;k] 
      double precision Fnew0, Fnew1, Fnew2
      double precision a0, a1, a2, a3, a4, a5, a6, a7, a8

      CHF_MULTIDO[box;i;j;k]
      
         if (CH_SPACEDIM==3) then
            
           if (inverse==0) then
               a0 = dxidX(CHF_IX[i;j;k],0)
               a1 = dxidX(CHF_IX[i;j;k],1)
               a2 = dxidX(CHF_IX[i;j;k],2)
               a3 = dxidX(CHF_IX[i;j;k],3)
               a4 = dxidX(CHF_IX[i;j;k],4)
               a5 = dxidX(CHF_IX[i;j;k],5)
               a6 = dxidX(CHF_IX[i;j;k],6)
               a7 = dxidX(CHF_IX[i;j;k],7)
               a8 = dxidX(CHF_IX[i;j;k],8)
            else
               a0 = dXdxi(CHF_IX[i;j;k],0)
               a1 = dXdxi(CHF_IX[i;j;k],1)
               a2 = dXdxi(CHF_IX[i;j;k],2)
               a3 = dXdxi(CHF_IX[i;j;k],3)
               a4 = dXdxi(CHF_IX[i;j;k],4)
               a5 = dXdxi(CHF_IX[i;j;k],5)
               a6 = dXdxi(CHF_IX[i;j;k],6)
               a7 = dXdxi(CHF_IX[i;j;k],7)
               a8 = dXdxi(CHF_IX[i;j;k],8)
            endif
  
            Fnew0 = a0*F(CHF_IX[i;j;k],0) + a3*F(CHF_IX[i;j;k],1) + a6*F(CHF_IX[i;j;k],2)
            Fnew1 = a1*F(CHF_IX[i;j;k],0) + a4*F(CHF_IX[i;j;k],1) + a7*F(CHF_IX[i;j;k],2)
            Fnew2 = a2*F(CHF_IX[i;j;k],0) + a5*F(CHF_IX[i;j;k],1) + a8*F(CHF_IX[i;j;k],2)

            F(CHF_IX[i;j;k],0) = Fnew0
            F(CHF_IX[i;j;k],1) = Fnew1
            F(CHF_IX[i;j;k],2) = Fnew2

         else

            if (inverse==0) then
               a0 = dxidX(CHF_IX[i;j;k],0)
               a1 = dxidX(CHF_IX[i;j;k],1)
               a2 = dxidX(CHF_IX[i;j;k],2)
               a3 = dxidX(CHF_IX[i;j;k],3)
            else
               a0 = dXdxi(CHF_IX[i;j;k],0)
               a1 = dXdxi(CHF_IX[i;j;k],1)
               a2 = dXdxi(CHF_IX[i;j;k],2)
               a3 = dXdxi(CHF_IX[i;j;k],3)
            endif
            
            Fnew0 = a0*F(CHF_IX[i;j;k],0) + a2*F(CHF_IX[i;j;k],1)
            Fnew1 = a1*F(CHF_IX[i;j;k],0) + a3*F(CHF_IX[i;j;k],1)

            F(CHF_IX[i;j;k],0) = Fnew0
            F(CHF_IX[i;j;k],1) = Fnew1

         endif

      CHF_ENDDO

      return
      end
      

      subroutine contra_to_covar(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[dXdxi],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_INT[inverse],
     &     CHF_FRA1[F])
      
      integer CHF_DDECL[i;j;k], l0, l1, l2 
      double precision gl0, gl1, gl2, glsq
      
      CHF_DTERM[
      l0 = 0 + CH_SPACEDIM*dir;
      l1 = 1 + CH_SPACEDIM*dir;
      l2 = 2 + CH_SPACEDIM*dir]

c        print*, "dir  = ", dir
c        print*, "iboxlo0  = ", iboxlo0
c        print*, "iboxhi0  = ", iboxhi0
c        print*, "iboxlo1  = ", iboxlo1
c        print*, "iboxhi1  = ", iboxhi1

      CHF_MULTIDO[box;i;j;k]
      
         if (CH_SPACEDIM==3) then

            gl0 = dXdxi(CHF_IX[i;j;k],l0)
            gl1 = dXdxi(CHF_IX[i;j;k],l1)
            gl2 = dXdxi(CHF_IX[i;j;k],l2)
  
            glsq = gl0*gl0 + gl1*gl1 + gl2*gl2

         else
            
            gl0 = dXdxi(CHF_IX[i;j;k],l0)
            gl1 = dXdxi(CHF_IX[i;j;k],l1)
  
            glsq = gl0*gl0 + gl1*gl1

         endif
        
c        print*, "CHF_IX[i;j;k]  = ", CHF_IX[i;j;k]
c        print*, "glsq  = ", glsq

         if (inverse==0) then
            F(CHF_IX[i;j;k]) = F(CHF_IX[i;j;k])*glsq
         else
            F(CHF_IX[i;j;k]) = F(CHF_IX[i;j;k])/glsq
         endif

      CHF_ENDDO

      return
      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      subroutine ncdivergence(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_REAL[dX],
     &     CHF_CONST_FRA1[JonNodes],
     &     CHF_CONST_FRA1[JonEdges],
     &     CHF_CONST_FRA[dXdxi],
     &     CHF_CONST_FRA[Fcovar],
     &     CHF_FRA[divF] )
      
      integer CHF_DDECL[i;j;k], l0, l1, l2, n 
      integer CHF_DDECL[ii;jj;kk]
      double precision gl0, gl1, gl2, glsqup, glsqdown
      double precision Jaup, Jadown, Janc, JaFcontra_up, JaFcontra_down      

      CHF_DTERM[
      l0 = 0 + CH_SPACEDIM*dir;
      l1 = 1 + CH_SPACEDIM*dir;
      l2 = 2 + CH_SPACEDIM*dir]
      
      CHF_DTERM[
      ii = CHF_ID(dir, 0);
      jj = CHF_ID(dir, 1);
      kk = CHF_ID(dir, 2)]

c        print*, "dir  = ", dir
c        print*, "iboxlo0  = ", iboxlo0
c        print*, "iboxhi0  = ", iboxhi0
c        print*, "iboxlo1  = ", iboxlo1
c        print*, "iboxhi1  = ", iboxhi1

      CHF_MULTIDO[box;i;j;k]
      
         if (CH_SPACEDIM==3) then

            gl0 = dXdxi(CHF_IX[i-ii;j-jj;k-kk],l0)
            gl1 = dXdxi(CHF_IX[i-ii;j-jj;k-kk],l1)
            gl2 = dXdxi(CHF_IX[i-ii;j-jj;k-kk],l2)
            glsqdown = gl0*gl0 + gl1*gl1 + gl2*gl2
            
            gl0 = dXdxi(CHF_IX[i;j;k],l0)
            gl1 = dXdxi(CHF_IX[i;j;k],l1)
            gl2 = dXdxi(CHF_IX[i;j;k],l2)
            glsqup = gl0*gl0 + gl1*gl1 + gl2*gl2

         else
            
            gl0 = dXdxi(CHF_IX[i-ii;j-jj;k-kk],l0)
            gl1 = dXdxi(CHF_IX[i-ii;j-jj;k-kk],l1)
            glsqdown = gl0*gl0 + gl1*gl1
            
            gl0 = dXdxi(CHF_IX[i;j;k],l0)
            gl1 = dXdxi(CHF_IX[i;j;k],l1)
            glsqup = gl0*gl0 + gl1*gl1

         endif
         Jadown = JonEdges(CHF_IX[i-ii;j-jj;k-kk])
         Jaup   = JonEdges(CHF_IX[i;j;k])
         Janc   = JonNodes(CHF_IX[i;j;k])
           
         do n=0, (CHF_NCOMP[divF]-1)
            JaFcontra_down = Jadown*Fcovar(CHF_IX[i-ii;j-jj;k-kk],n)/glsqdown
            JaFcontra_up   = Jaup*Fcovar(CHF_IX[i;j;k],n)/glsqup
            if(Janc==0.0) then
               if(dir==0) then
                  divF(CHF_IX[i;j;k],n) = divF(CHF_IX[i;j;k],n) + 4.0*Fcovar(CHF_IX[i;j;k],n)/glsqup/dX
               else
                  JaFcontra_down = Fcovar(CHF_IX[i-ii;j-jj;k-kk],n)/glsqdown
                  JaFcontra_up   = Fcovar(CHF_IX[i;j;k],n)/glsqup
                  divF(CHF_IX[i;j;k],n) = divF(CHF_IX[i;j;k],n) + (JaFcontra_up - JaFcontra_down)/dX
               endif
            else
               JaFcontra_down = Jadown*Fcovar(CHF_IX[i-ii;j-jj;k-kk],n)/glsqdown
               JaFcontra_up   = Jaup*Fcovar(CHF_IX[i;j;k],n)/glsqup
               divF(CHF_IX[i;j;k],n) = divF(CHF_IX[i;j;k],n) + (JaFcontra_up - JaFcontra_down)/dX/Janc
            endif
         enddo

      CHF_ENDDO

      return
      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      subroutine ecdivergence(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_REAL[dX],
     &     CHF_CONST_REAL[dZ],
     &     CHF_CONST_FRA1[JonCells],
     &     CHF_CONST_FRA1[JonNodes],
     &     CHF_CONST_FRA1[JonEdges],
     &     CHF_CONST_FRA1[Fcells],
     &     CHF_CONST_FRA1[Fnodes],
     &     CHF_FRA1[divF] )
      
      integer CHF_DDECL[i;j;k], l0, l1, l2, n 
      integer CHF_DDECL[ii;jj;kk]
      double precision Jaec, JaFlux_Xup, JaFlux_Xdn, JaFlux_Zup, JaFlux_Zdn      

      CHF_DTERM[
      l0 = 0 + CH_SPACEDIM*dir;
      l1 = 1 + CH_SPACEDIM*dir;
      l2 = 2 + CH_SPACEDIM*dir]
      
      CHF_DTERM[
      ii = CHF_ID(dir, 0);
      jj = CHF_ID(dir, 1);
      kk = CHF_ID(dir, 2)]

      CHF_MULTIDO[box;i;j;k]
      
         Jaec   = JonEdges(CHF_IX[i;j;k])
         if(dir.eq.0) then
            JaFlux_Xup = Fnodes(CHF_IX[i+1;j;k])*JonNodes(CHF_IX[i+1;j;k])
            JaFlux_Xdn = Fnodes(CHF_IX[i;j;k])*JonNodes(CHF_IX[i;j;k])
            JaFlux_Zup = Fcells(CHF_IX[i;j;k])*JonCells(CHF_IX[i;j;k])
            JaFlux_Zdn = Fcells(CHF_IX[i;j-1;k])*JonCells(CHF_IX[i;j-1;k])
         else
            JaFlux_Zup = Fnodes(CHF_IX[i;j+1;k])*JonNodes(CHF_IX[i;j+1;k])
            JaFlux_Zdn = Fnodes(CHF_IX[i;j;k])*JonNodes(CHF_IX[i;j;k])
            JaFlux_Xup = Fcells(CHF_IX[i;j;k])*JonCells(CHF_IX[i;j;k])
            JaFlux_Xdn = Fcells(CHF_IX[i-1;j;k])*JonCells(CHF_IX[i-1;j;k])
         endif 
 
         if(Jaec==0.0) then
            divF(CHF_IX[i;j;k]) = (Fnodes(CHF_IX[i;j+1;k])-Fnodes(CHF_IX[i;j;k]))/dZ
         else
            divF(CHF_IX[i;j;k]) = (JaFlux_Xup - JaFlux_Xdn)/dX/Jaec
     &                          + (JaFlux_Zup - JaFlux_Zdn)/dZ/Jaec
         endif

      CHF_ENDDO

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    COMPUTE STRAIN TENSOR FOR 2D CASE

      subroutine eval_strain_tensor_comps(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA1[divV],
     &     CHF_CONST_FRA[gradVx],
     &     CHF_CONST_FRA[gradVy],
     &     CHF_FRA[Wx],
     &     CHF_FRA[Wy]
     &     )

c     local variables
      integer CHF_AUTODECL[i]
      double precision divV0
      double precision gradVxx, gradVxy
      double precision gradVyx, gradVyy

      CHF_AUTOMULTIDO[gridbox;i]

      if (CH_SPACEDIM==3) then

      else

        gradVxx = gradVx(CHF_AUTOIX[i],0)
        gradVxy = gradVx(CHF_AUTOIX[i],1)
        gradVyx = gradVy(CHF_AUTOIX[i],0)
        gradVyy = gradVy(CHF_AUTOIX[i],1)
        divV0  = divV(CHF_AUTOIX[i])

        Wx(CHF_AUTOIX[i],0) = gradVxx + gradVxx - two/three*divV0
        Wx(CHF_AUTOIX[i],1) = gradVxy + gradVyx
        Wy(CHF_AUTOIX[i],0) = gradVyx + gradVxy
        Wy(CHF_AUTOIX[i],1) = gradVyy + gradVyy - two/three*divV0

      endif

      CHF_ENDDO
    
      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    COMPUTE STRAIN TENSOR FOR 2D CASE

      subroutine eval_strain_tensor_comps_new(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA1[divV],
     &     CHF_CONST_FRA[gradVx],
     &     CHF_CONST_FRA[gradVy],
     &     CHF_FRA[W],
     &     )

c     local variables
      integer CHF_AUTODECL[i]
      double precision divV0
      double precision gradVxx, gradVxy
      double precision gradVyx, gradVyy

      CHF_AUTOMULTIDO[gridbox;i]

      if (CH_SPACEDIM==3) then

      else

        gradVxx = gradVx(CHF_AUTOIX[i],0)
        gradVxy = gradVx(CHF_AUTOIX[i],1)
        gradVyx = gradVy(CHF_AUTOIX[i],0)
        gradVyy = gradVy(CHF_AUTOIX[i],1)
        divV0  = divV(CHF_AUTOIX[i])

        W(CHF_AUTOIX[i],0) = gradVxx + gradVxx - two/three*divV0
        W(CHF_AUTOIX[i],1) = gradVxy + gradVyx
        W(CHF_AUTOIX[i],2) = gradVyx + gradVxy
        W(CHF_AUTOIX[i],3) = gradVyy + gradVyy - two/three*divV0

      endif

      CHF_ENDDO
    
      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine compute_face_transverse_E(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_FRA1[phi],
     &     CHF_FRA1[E])
c     local variables
      integer CHF_DDECL[i;j;k], CHF_DDECL[ii;jj;kk], tdir

      tdir = 1 - dir

      CHF_DTERM[
      ii = CHF_ID(0,tdir);
      jj = CHF_ID(1,tdir);
      kk = CHF_ID(2,tdir)]

      CHF_MULTIDO[box;i;j;k]
         E(CHF_IX[i;j;k]) = (phi(CHF_IX[i;j;k]) - phi(CHF_IX[i+ii;j+jj;k+kk])) / dx(tdir)
      CHF_ENDDO

      return
      end


      subroutine compute_exb_drift(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[E],
     &     CHF_CONST_FRA[B],
     &     CHF_CONST_FRA1[Bmag],
     &     CHF_FRA[ExB])
c     local variables
      integer CHF_DDECL[i;j;k]

      CHF_MULTIDO[box;i;j;k]
       
       ExB(CHF_IX[i;j;k],0) = E(CHF_IX[i;j;k],1)*B(CHF_IX[i;j;k],2) - E(CHF_IX[i;j;k],2)*B(CHF_IX[i;j;k],1)
       ExB(CHF_IX[i;j;k],1) = E(CHF_IX[i;j;k],2)*B(CHF_IX[i;j;k],0) - E(CHF_IX[i;j;k],0)*B(CHF_IX[i;j;k],2)
       ExB(CHF_IX[i;j;k],2) = E(CHF_IX[i;j;k],0)*B(CHF_IX[i;j;k],1) - E(CHF_IX[i;j;k],1)*B(CHF_IX[i;j;k],0)

       ExB(CHF_IX[i;j;k],0) = ExB(CHF_IX[i;j;k],0) / Bmag(CHF_IX[i;j;k])**2
       ExB(CHF_IX[i;j;k],1) = ExB(CHF_IX[i;j;k],1) / Bmag(CHF_IX[i;j;k])**2
       ExB(CHF_IX[i;j;k],2) = ExB(CHF_IX[i;j;k],2) / Bmag(CHF_IX[i;j;k])**2

      CHF_ENDDO

      return
      end


      subroutine compute_volume_B_integrals(
     &     CHF_BOX[box],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_FRA[B],
     &     CHF_CONST_FRA1[jacobian],
     &     CHF_FRA[integral])
c     local variables
      integer CHF_DDECL[i;j;k], comp
      double precision sum, area

      area = dx(0) * dx(1)

      CHF_MULTIDO[box;i;j;k]
      
         do comp = 0, 2
            integral(CHF_IX[i;j;k],comp) = B(CHF_IX[i;j;k],comp) * jacobian(CHF_IX[i;j;k]) * area
         enddo

      CHF_ENDDO

      return
      end

      subroutine compute_volume_B_dot_E_integrals(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[E],
     &     CHF_CONST_FRA[Bintegral],
     &     CHF_FRA1[integral])
c     local variables
      integer CHF_DDECL[i;j;k], comp
      double precision sum

      CHF_MULTIDO[box;i;j;k]
      
         sum = zero
         do comp = 0, 2
            sum = sum + E(CHF_IX[i;j;k],comp) * Bintegral(CHF_IX[i;j;k],comp) 
         enddo

         integral(CHF_IX[i;j;k]) = sum

      CHF_ENDDO

      return
      end


      subroutine compute_volume_B_dot_E_integrals_field_aligned(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA1[phi_node],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_FRA[njinverse],
     &     CHF_CONST_FRA[Bintegral],
     &     CHF_FRA1[integral])
c     local variables
      integer CHF_DDECL[i;j;k], comp, m, row, col
      double precision sum, Epol_mapped(0:1), Epol_phys(0:1), E_phys(0:2)

      CHF_MULTIDO[box;i;j;k]
      
         Epol_mapped(0) = 0.0
         Epol_mapped(1) = -0.5 * (phi_node(CHF_IX[i;j+1;k]) - phi_node(CHF_IX[i;j;k]) + phi_node(CHF_IX[i+1;j+1;k]) - phi_node(CHF_IX[i+1;j;k]))

         Epol_mapped(1) = Epol_mapped(1)/dx(1)

         m = 0
         do row = 0, CH_SPACEDIM-1
            sum = zero
            do col = 0, CH_SPACEDIM-1
               sum = sum + njinverse(CHF_IX[i;j;k],m) * Epol_mapped(col)
	              m = m + 1
            enddo
            Epol_phys(row) = sum
         enddo

         E_phys(0) = Epol_phys(0)
         E_phys(1) = 0.0
         E_phys(2) = Epol_phys(1)

         sum = zero
         do comp = 0, 2
            sum = sum + E_phys(comp) * Bintegral(CHF_IX[i;j;k],comp) 
         enddo

         integral(CHF_IX[i;j;k]) = sum

      CHF_ENDDO

      return
      end



      subroutine compute_volume_B_dot_gradB_integrals(
     &     CHF_BOX[box],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_CONST_FRA[B],
     &     CHF_CONST_FRA[gradB],
     &     CHF_CONST_FRA1[jacobian],
     &     CHF_FRA1[integral])
c     local variables
      integer CHF_DDECL[i;j;k], comp
      double precision sum, area

      area = dx(0) * dx(1)

      CHF_MULTIDO[box;i;j;k]
      
         sum = zero
         do comp = 0, 2
            sum = sum - gradB(CHF_IX[i;j;k],comp) * B(CHF_IX[i;j;k],comp) 
         enddo

         integral(CHF_IX[i;j;k]) = sum * jacobian(CHF_IX[i;j;k]) * area

      CHF_ENDDO

      return
      end

      subroutine compute_elliptic_op_coeff(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[bunit],
     &     CHF_FRA[perp_coef],
     &     CHF_FRA[par_coef],
     &     )

c     local variables
      integer CHF_DDECL[i;j;k]

      CHF_MULTIDO[box;i;j;k]

c        Coefficients in cylindrical coordinate frame

#if CH_SPACEDIM==3
         perp_coef(CHF_IX[i;j;k],0) = one - bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],0)
         perp_coef(CHF_IX[i;j;k],1) =     - bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],1)
         perp_coef(CHF_IX[i;j;k],2) =     - bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],2)
         perp_coef(CHF_IX[i;j;k],3) =     - bunit(CHF_IX[i;j;k],1) * bunit(CHF_IX[i;j;k],0)
         perp_coef(CHF_IX[i;j;k],4) = one - bunit(CHF_IX[i;j;k],1) * bunit(CHF_IX[i;j;k],1)
         perp_coef(CHF_IX[i;j;k],5) =     - bunit(CHF_IX[i;j;k],1) * bunit(CHF_IX[i;j;k],2)
         perp_coef(CHF_IX[i;j;k],6) =     - bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],0)
         perp_coef(CHF_IX[i;j;k],7) =     - bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],1)
         perp_coef(CHF_IX[i;j;k],8) = one - bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],2)

         par_coef(CHF_IX[i;j;k],0) = bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],0)
         par_coef(CHF_IX[i;j;k],1) = bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],1)
         par_coef(CHF_IX[i;j;k],2) = bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],2)
         par_coef(CHF_IX[i;j;k],3) = bunit(CHF_IX[i;j;k],1) * bunit(CHF_IX[i;j;k],0)
         par_coef(CHF_IX[i;j;k],4) = bunit(CHF_IX[i;j;k],1) * bunit(CHF_IX[i;j;k],1)
         par_coef(CHF_IX[i;j;k],5) = bunit(CHF_IX[i;j;k],1) * bunit(CHF_IX[i;j;k],2)
         par_coef(CHF_IX[i;j;k],6) = bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],0)
         par_coef(CHF_IX[i;j;k],7) = bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],1)
         par_coef(CHF_IX[i;j;k],8) = bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],2)

#else
         perp_coef(CHF_IX[i;j;k],0) =  one - bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],0)
         perp_coef(CHF_IX[i;j;k],1) =      - bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],2)
         perp_coef(CHF_IX[i;j;k],2) =      - bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],0)
         perp_coef(CHF_IX[i;j;k],3) =  one - bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],2)

         par_coef(CHF_IX[i;j;k],0) =   bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],0)
         par_coef(CHF_IX[i;j;k],1) =   bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],2)
         par_coef(CHF_IX[i;j;k],2) =   bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],0)
         par_coef(CHF_IX[i;j;k],3) =   bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],2)
#endif

         
      CHF_ENDDO

      return
      end


      subroutine compute_elliptic_op_coeff_mapped(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[n],
     &     CHF_CONST_FRA[njinverse],
     &     CHF_FRA[coef]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k], row, col, m
      double precision n_mat(0:CH_SPACEDIM-1,0:CH_SPACEDIM-1), nji_mat(0:CH_SPACEDIM-1,0:CH_SPACEDIM-1),
     &     d_mat(0:CH_SPACEDIM-1,0:CH_SPACEDIM-1), dnji_mat(0:CH_SPACEDIM-1,0:CH_SPACEDIM-1),
     &     coef_mat(0:CH_SPACEDIM-1,0:CH_SPACEDIM-1)

      CHF_MULTIDO[box;i;j;k]

c        Coefficients in cylindrical coordinate frame

#if CH_SPACEDIM==3
         d_mat(0,0) = coef(CHF_IX[i;j;k],0)
         d_mat(0,1) = coef(CHF_IX[i;j;k],1)
         d_mat(0,2) = coef(CHF_IX[i;j;k],2)
         d_mat(1,0) = coef(CHF_IX[i;j;k],3)
         d_mat(1,1) = coef(CHF_IX[i;j;k],4)
         d_mat(1,2) = coef(CHF_IX[i;j;k],5)
         d_mat(2,0) = coef(CHF_IX[i;j;k],6)
         d_mat(2,1) = coef(CHF_IX[i;j;k],7)
         d_mat(2,2) = coef(CHF_IX[i;j;k],8)

         nji_mat(0,0) = njinverse(CHF_IX[i;j;k],0)
         nji_mat(0,1) = njinverse(CHF_IX[i;j;k],1)
         nji_mat(0,2) = njinverse(CHF_IX[i;j;k],2)
         nji_mat(1,0) = njinverse(CHF_IX[i;j;k],3)
         nji_mat(1,1) = njinverse(CHF_IX[i;j;k],4)
         nji_mat(1,2) = njinverse(CHF_IX[i;j;k],5)
         nji_mat(2,0) = njinverse(CHF_IX[i;j;k],6)
         nji_mat(2,1) = njinverse(CHF_IX[i;j;k],7)
         nji_mat(2,2) = njinverse(CHF_IX[i;j;k],8)

         n_mat(0,0) = n(CHF_IX[i;j;k],0)
         n_mat(0,1) = n(CHF_IX[i;j;k],1)
         n_mat(0,2) = n(CHF_IX[i;j;k],2)
         n_mat(1,0) = n(CHF_IX[i;j;k],3)
         n_mat(1,1) = n(CHF_IX[i;j;k],4)
         n_mat(1,2) = n(CHF_IX[i;j;k],5)
         n_mat(2,0) = n(CHF_IX[i;j;k],6)
         n_mat(2,1) = n(CHF_IX[i;j;k],7)
         n_mat(2,2) = n(CHF_IX[i;j;k],8)
#else
         d_mat(0,0) = coef(CHF_IX[i;j;k],0)
         d_mat(0,1) = coef(CHF_IX[i;j;k],1)
         d_mat(1,0) = coef(CHF_IX[i;j;k],2)
         d_mat(1,1) = coef(CHF_IX[i;j;k],3)

         nji_mat(0,0) = njinverse(CHF_IX[i;j;k],0)
         nji_mat(0,1) = njinverse(CHF_IX[i;j;k],1)
         nji_mat(1,0) = njinverse(CHF_IX[i;j;k],2)
         nji_mat(1,1) = njinverse(CHF_IX[i;j;k],3)

         n_mat(0,0) = n(CHF_IX[i;j;k],0)
         n_mat(0,1) = n(CHF_IX[i;j;k],1)
         n_mat(1,0) = n(CHF_IX[i;j;k],2)
         n_mat(1,1) = n(CHF_IX[i;j;k],3)
#endif

c        Multiply the coefficient matrix times the NJInverse matrix
         do row = 0, CH_SPACEDIM-1
            do col = 0, CH_SPACEDIM-1
               dnji_mat(row,col) = zero
               do m = 0, CH_SPACEDIM-1
                  dnji_mat(row,col) = dnji_mat(row,col) + d_mat(row,m) * nji_mat(m,col)
               enddo
            enddo
         enddo

c        Premultiply by the NTranspose matrix
         do row = 0, CH_SPACEDIM-1
            do col = 0, CH_SPACEDIM-1
               coef_mat(row,col) = zero
               do m = 0, CH_SPACEDIM-1
                  coef_mat(row,col) = coef_mat(row,col) + n_mat(m,row) * dnji_mat(m,col)
               enddo
            enddo
         enddo

#if CH_SPACEDIM==3
         coef(CHF_IX[i;j;k],0) = coef_mat(0,0)
         coef(CHF_IX[i;j;k],1) = coef_mat(0,1)
         coef(CHF_IX[i;j;k],2) = coef_mat(0,2)
         coef(CHF_IX[i;j;k],3) = coef_mat(1,0)
         coef(CHF_IX[i;j;k],4) = coef_mat(1,1)
         coef(CHF_IX[i;j;k],5) = coef_mat(1,2)
         coef(CHF_IX[i;j;k],6) = coef_mat(2,0)
         coef(CHF_IX[i;j;k],7) = coef_mat(2,1)
         coef(CHF_IX[i;j;k],8) = coef_mat(2,2)
#else
         coef(CHF_IX[i;j;k],0) = coef_mat(0,0)
         coef(CHF_IX[i;j;k],1) = coef_mat(0,1)
         coef(CHF_IX[i;j;k],2) = coef_mat(1,0)
         coef(CHF_IX[i;j;k],3) = coef_mat(1,1)
#endif

      CHF_ENDDO

      return
      end

      subroutine compute_radial_elliptic_op_coeff(
     &     CHF_BOX[box],
     &     CHF_CONST_FRA[bunit],
     &     CHF_FRA[rad_coef],
     &     )

c     local variables
      integer CHF_DDECL[i;j;k]
      double precision fac

      CHF_MULTIDO[box;i;j;k]

c        Coefficients in cylindrical coordinate frame;
c        Defines physical flux projection onto the radial dir (i.e., normal to magnetic flux) 
c        Note that in 3D physical components are R,Phi,Z 

         fac = one/(bunit(CHF_IX[i;j;k],0)**2 + bunit(CHF_IX[i;j;k],2)**2)

#if CH_SPACEDIM==3
         rad_coef(CHF_IX[i;j;k],0) = fac * bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],2)
         rad_coef(CHF_IX[i;j;k],1) = zero
         rad_coef(CHF_IX[i;j;k],2) =-fac * bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],0)
         rad_coef(CHF_IX[i;j;k],3) = zero
         rad_coef(CHF_IX[i;j;k],4) = zero
         rad_coef(CHF_IX[i;j;k],5) = zero
         rad_coef(CHF_IX[i;j;k],6) = -fac * bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],0)
         rad_coef(CHF_IX[i;j;k],7) = zero
         rad_coef(CHF_IX[i;j;k],8) = fac * bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],0)
#else
         rad_coef(CHF_IX[i;j;k],0) = fac * bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],2)
         rad_coef(CHF_IX[i;j;k],1) =-fac * bunit(CHF_IX[i;j;k],2) * bunit(CHF_IX[i;j;k],0)
         rad_coef(CHF_IX[i;j;k],2) =-fac * bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],2)
         rad_coef(CHF_IX[i;j;k],3) = fac * bunit(CHF_IX[i;j;k],0) * bunit(CHF_IX[i;j;k],0)

#endif

         
      CHF_ENDDO

      return
      end
