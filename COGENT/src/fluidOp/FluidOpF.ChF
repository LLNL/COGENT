
c    COMPUTE FLUX-FREEZING SPEED

      subroutine eval_flux_freezing_speed(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA1[RHO],
     &     CHF_CONST_FRA1[P],
     &     CHF_CONST_FRA1[magP],
     &     CHF_CONST_FRA[V],
     &     CHF_CONST_FRA[N],
     &     CHF_CONST_FRA1[J],
     &     CHF_CONST_REAL[gamma],
     &     CHF_CONST_INT[includeP],
     &     CHF_CONST_INT[includePmag],
     &     CHF_FRA[Cspeed]
     &     )

c     local variables
      integer CHF_AUTODECL[i]
      double precision C0, Cspeed1, Cspeed2, Cspeed3, Vmap1, Vmap2, Vmap3
      double precision dq1dx1, dq1dx2, dq1dx3
      double precision dq2dx1, dq2dx2, dq2dx3
      double precision dq3dx1, dq3dx2, dq3dx3

c        print*, "shape N_cent       = ", shape(N)

      CHF_AUTOMULTIDO[gridbox;i]

         C0  = sqrt( ( includeP*gamma*P(CHF_AUTOIX[i]) 
     &               + includePmag*2.0*magP(CHF_AUTOIX[i]) )/RHO(CHF_AUTOIX[i]) )

         if (CH_SPACEDIM==3) then
            
            dq1dx1 = N(CHF_AUTOIX[i],0)/J(CHF_AUTOIX[i])
            dq1dx2 = N(CHF_AUTOIX[i],3)/J(CHF_AUTOIX[i])
            dq1dx3 = N(CHF_AUTOIX[i],6)/J(CHF_AUTOIX[i])
            dq2dx1 = N(CHF_AUTOIX[i],1)/J(CHF_AUTOIX[i])
            dq2dx2 = N(CHF_AUTOIX[i],4)/J(CHF_AUTOIX[i])
            dq2dx3 = N(CHF_AUTOIX[i],7)/J(CHF_AUTOIX[i])
            dq3dx1 = N(CHF_AUTOIX[i],2)/J(CHF_AUTOIX[i])
            dq3dx2 = N(CHF_AUTOIX[i],5)/J(CHF_AUTOIX[i])
            dq3dx3 = N(CHF_AUTOIX[i],8)/J(CHF_AUTOIX[i])
            
            Vmap1 = dq1dx1*V(CHF_AUTOIX[i],0) 
     &            + dq1dx2*V(CHF_AUTOIX[i],1) 
     &            + dq1dx3*V(CHF_AUTOIX[i],2) 
            Vmap2 = dq2dx1*V(CHF_AUTOIX[i],0) 
     &            + dq2dx2*V(CHF_AUTOIX[i],1) 
     &            + dq2dx3*V(CHF_AUTOIX[i],2) 
            Vmap3 = dq3dx1*V(CHF_AUTOIX[i],0) 
     &            + dq3dx2*V(CHF_AUTOIX[i],1) 
     &            + dq3dx3*V(CHF_AUTOIX[i],2) 
 
            Cspeed1  = C0*sqrt( dq1dx1**2 + dq1dx2**2 + dq1dx3**2 )
            Cspeed2  = C0*sqrt( dq2dx1**2 + dq2dx2**2 + dq2dx3**2 )
            Cspeed3  = C0*sqrt( dq3dx1**2 + dq3dx2**2 + dq3dx3**2 )
            
            Cspeed(CHF_AUTOIX[i],0) = abs(Vmap1) + Cspeed1
            Cspeed(CHF_AUTOIX[i],1) = abs(Vmap2) + Cspeed2
            Cspeed(CHF_AUTOIX[i],2) = abs(Vmap3) + Cspeed3
     
         else

            dq1dx1 = N(CHF_AUTOIX[i],0)/J(CHF_AUTOIX[i])
            dq1dx2 = N(CHF_AUTOIX[i],2)/J(CHF_AUTOIX[i])
            dq2dx1 = N(CHF_AUTOIX[i],1)/J(CHF_AUTOIX[i])
            dq2dx2 = N(CHF_AUTOIX[i],3)/J(CHF_AUTOIX[i])
      
            Vmap1 = dq1dx1*V(CHF_AUTOIX[i],0) 
     &            + dq1dx2*V(CHF_AUTOIX[i],1) 
            Vmap2 = dq2dx1*V(CHF_AUTOIX[i],0) 
     &            + dq2dx2*V(CHF_AUTOIX[i],1) 
 
            Cspeed1  = C0*sqrt( dq1dx1**2 + dq1dx2**2 )
            Cspeed2  = C0*sqrt( dq2dx1**2 + dq2dx2**2 )
c            print*, "shape(P)   = ", shape(P)
c            print*, "Cspeed1    = ", Cspeed1
c            print*, "CHF_AUTOIX[i]    = ", CHF_AUTOIX[i]
c            print*, "dq1dx1    = ", dq1dx1
c            print*, "dq1dx2    = ", dq1dx2
c            print*, "dq2dx1    = ", dq2dx1
c            print*, "dq2dx2    = ", dq2dx2

            Cspeed(CHF_AUTOIX[i],0) = abs(Vmap1) + Cspeed1
            Cspeed(CHF_AUTOIX[i],1) = abs(Vmap2) + Cspeed2
c            Cspeed(CHF_AUTOIX[i],0) = abs(V(CHF_AUTOIX[i],0)) + C0
c            Cspeed(CHF_AUTOIX[i],1) = abs(V(CHF_AUTOIX[i],1)) + C0
      
         endif
 
      CHF_ENDDO

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    COMPUTE MAPPED LIGHT SPEED

      subroutine eval_mapped_light_speed(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA[N],
     &     CHF_CONST_FRA1[J],
     &     CHF_CONST_REAL[delta],
     &     CHF_FRA[Clight]
     &     )

c     local variables
      integer CHF_AUTODECL[i]
      double precision C0
      double precision dq1dx1, dq1dx2, dq1dx3
      double precision dq2dx1, dq2dx2, dq2dx3
      double precision dq3dx1, dq3dx2, dq3dx3

      C0  = one/sqrt( delta )

      CHF_AUTOMULTIDO[gridbox;i]

         if (CH_SPACEDIM==3) then

            dq1dx1 = N(CHF_AUTOIX[i],0)/J(CHF_AUTOIX[i])
            dq1dx2 = N(CHF_AUTOIX[i],3)/J(CHF_AUTOIX[i])
            dq1dx3 = N(CHF_AUTOIX[i],6)/J(CHF_AUTOIX[i])
            dq2dx1 = N(CHF_AUTOIX[i],1)/J(CHF_AUTOIX[i])
            dq2dx2 = N(CHF_AUTOIX[i],4)/J(CHF_AUTOIX[i])
            dq2dx3 = N(CHF_AUTOIX[i],7)/J(CHF_AUTOIX[i])
            dq3dx1 = N(CHF_AUTOIX[i],2)/J(CHF_AUTOIX[i])
            dq3dx2 = N(CHF_AUTOIX[i],5)/J(CHF_AUTOIX[i])
            dq3dx3 = N(CHF_AUTOIX[i],8)/J(CHF_AUTOIX[i])

            Clight(CHF_AUTOIX[i],0) = C0*sqrt( dq1dx1**2 + dq1dx2**2 + dq1dx3**2 )
            Clight(CHF_AUTOIX[i],1) = C0*sqrt( dq2dx1**2 + dq2dx2**2 + dq2dx3**2 )
            Clight(CHF_AUTOIX[i],2) = C0*sqrt( dq3dx1**2 + dq3dx2**2 + dq3dx3**2 )

         else

            dq1dx1 = N(CHF_AUTOIX[i],0)/J(CHF_AUTOIX[i])
            dq1dx2 = N(CHF_AUTOIX[i],2)/J(CHF_AUTOIX[i])
            dq2dx1 = N(CHF_AUTOIX[i],1)/J(CHF_AUTOIX[i])
            dq2dx2 = N(CHF_AUTOIX[i],3)/J(CHF_AUTOIX[i])

            Clight(CHF_AUTOIX[i],0) = C0*sqrt( dq1dx1**2 + dq1dx2**2 )
            Clight(CHF_AUTOIX[i],1) = C0*sqrt( dq2dx1**2 + dq2dx2**2 )

         endif

      CHF_ENDDO

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    RETURN SQUARE OF EACH ROW OF METRIC TENSOR NT

      subroutine mag_nt_row_sq(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA[N],
     &     CHF_FRA[NTmagRowSq]
     &     )

c     local variables
      integer CHF_AUTODECL[i]
      double precision norm0, norm1, norm2

      CHF_AUTOMULTIDO[gridbox;i]

      if (CH_SPACEDIM==3) then

        norm0  = N(CHF_AUTOIX[i],0)**2 + N(CHF_AUTOIX[i],3)**2 + N(CHF_AUTOIX[i],6)**2
        norm1  = N(CHF_AUTOIX[i],1)**2 + N(CHF_AUTOIX[i],4)**2 + N(CHF_AUTOIX[i],7)**2
        norm2  = N(CHF_AUTOIX[i],2)**2 + N(CHF_AUTOIX[i],5)**2 + N(CHF_AUTOIX[i],8)**2
        NTmagRowSq(CHF_AUTOIX[i],0) = norm0
        NTmagRowSq(CHF_AUTOIX[i],1) = norm1
        NTmagRowSq(CHF_AUTOIX[i],2) = norm2

      else 

        norm0  = N(CHF_AUTOIX[i],0)**2 + N(CHF_AUTOIX[i],2)**2
        norm1  = N(CHF_AUTOIX[i],1)**2 + N(CHF_AUTOIX[i],3)**2
        NTmagRowSq(CHF_AUTOIX[i],0) = norm0
        NTmagRowSq(CHF_AUTOIX[i],1) = norm1

      endif

      CHF_ENDDO

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    compute collision terms

      subroutine eval_collision_terms(
     &     CHF_BOX[cellbox],
     &     CHF_CONST_REAL[tscale_s],
     &     CHF_CONST_REAL[Tscale_eV],
     &     CHF_CONST_REAL[tauiscale1eV_s],
     &     CHF_CONST_REAL[tauescale1eV_s],
     &     CHF_CONST_REAL[Le0sq],
     &     CHF_CONST_REAL[wciscale_Hz],
     &     CHF_CONST_REAL[wcescale_Hz],
     &     CHF_CONST_REAL[mM],
     &     CHF_CONST_REAL[gamma],
     &     CHF_CONST_REAL[etaResMin],
     &     CHF_CONST_FRA1[By],
     &     CHF_CONST_FRA1[den],
     &     CHF_CONST_FRA1[Pele],
     &     CHF_CONST_FRA1[Pion],
     &     CHF_FRA1[taui],
     &     CHF_FRA1[taue],
     &     CHF_FRA1[etaRes],
     &     CHF_FRA1[Qie],
     &     CHF_FRA1[xi],
     &     CHF_FRA1[xe]
     &     )

c     local variables
      integer n, CHF_AUTODECL[i]
      double precision By0, den0, Ti_eV, Te_eV, Clogii, Clogei
      double precision Pion0, Pele0

      CHF_AUTOMULTIDO[cellbox;i]

         By0   = By(CHF_AUTOIX[i])
         den0  = den(CHF_AUTOIX[i])
         Pion0 = Pion(CHF_AUTOIX[i])
         Pele0 = Pele(CHF_AUTOIX[i])
         Ti_eV = Tscale_eV*Pion0/den0
         Te_eV = Tscale_eV*Pele0/den0
         Clogii = 10.0
         Clogei = 10.0

         taui(CHF_AUTOIX[i]) = tauiscale1eV_s*10.0/Clogii*Ti_eV*sqrt(Ti_eV)/den0/tscale_s
         taue(CHF_AUTOIX[i]) = tauescale1eV_s*10.0/Clogei*Te_eV*sqrt(Te_eV)/den0/tscale_s

         if(etaResMin>0.0) then
            etaRes(CHF_AUTOIX[i]) = Le0sq/taue(CHF_AUTOIX[i])/den0 + etaResMin
         else 
            etaRes(CHF_AUTOIX[i]) = 0.0
         endif
  
         Qie(CHF_AUTOIX[i]) = 2.0/(gamma-1.0)*mM*( 1.0/taue(CHF_AUTOIX[i]) )*(Pele0 - Pion0)

         xi(CHF_AUTOIX[i]) = wciscale_Hz*By0*tscale_s*taui(CHF_AUTOIX[i])
         xe(CHF_AUTOIX[i]) = wcescale_Hz*By0*tscale_s*taue(CHF_AUTOIX[i])

      CHF_ENDDO

      return
      end


ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    compute source terms for energy equations

      subroutine eval_energy_source_terms(
     &     CHF_BOX[cellbox],
     &     CHF_CONST_INT[useFiniteIon],
     &     CHF_CONST_REAL[lambdai],
     &     CHF_CONST_FRA1[Ja],
     &     CHF_CONST_FRA1[eta],
     &     CHF_CONST_FRA1[Qie],
     &     CHF_CONST_FRA1[den],
     &     CHF_CONST_FRA[JaJxB],
     &     CHF_CONST_FRA[gradPe],
     &     CHF_CONST_FRA[gradTeeff],
     &     CHF_CONST_FRA[NU],
     &     CHF_CONST_FRA[Ecc],
     &     CHF_CONST_FRA[Jcc],
     &     CHF_FRA1[JaSion],
     &     CHF_FRA1[JaSele]
     &     )

c     local variables
      integer n, CHF_AUTODECL[i]
      double precision Ja0, eta0, NU0, Ecc0, Jcc0, JdotE0, NUdotE0
      double precision Qie0, den0, gradPe0, gradTeeff0, JxB0 

      CHF_AUTOMULTIDO[cellbox;i]

         Ja0   = Ja(CHF_AUTOIX[i])
         eta0  = eta(CHF_AUTOIX[i])
         Qie0  = Qie(CHF_AUTOIX[i])
         den0  = den(CHF_AUTOIX[i])

         JdotE0  = 0.0
         NUdotE0 = 0.0
         do n=0, (CH_SPACEDIM-1)
            JxB0  = JaJxB(CHF_AUTOIX[i],n)/Ja0
            gradPe0 = gradPe(CHF_AUTOIX[i],n)
            gradTeeff0 = gradTeeff(CHF_AUTOIX[i],n)
            Ecc0 = Ecc(CHF_AUTOIX[i],n)
            Jcc0 = Jcc(CHF_AUTOIX[i],n)
            NU0  = NU(CHF_AUTOIX[i],n)
            if(useFiniteIon.eq.zero) then
               JdotE0  = JdotE0  + Jcc0*Ecc0
               NUdotE0 = NUdotE0 + NU0*(JxB0 - gradPe0)/den0
            else
               JdotE0  = JdotE0  + Jcc0*( Ecc0 + gradTeeff0*lambdai )
               NUdotE0 = NUdotE0 + NU0*(Ecc0 - eta0*Jcc0)/lambdai
            endif
         enddo

         JaSion(CHF_AUTOIX[i]) = Ja0*(NUdotE0 + Qie0)
         JaSele(CHF_AUTOIX[i]) = Ja0*JdotE0 - JaSion(CHF_AUTOIX[i])

      CHF_ENDDO

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    COMPUTE VISCOSITY ENERGY FLUX

      subroutine eval_visc_energy_flux(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA[Vel],
     &     CHF_CONST_FRA[Pix],
     &     CHF_CONST_FRA[Piy],
     &     CHF_FRA[UPi]
     &     )

c     local variables
      integer CHF_AUTODECL[i]
      double precision Vx0, Vy0

      CHF_AUTOMULTIDO[gridbox;i]

      if (CH_SPACEDIM==3) then

      else

        Vx0  = Vel(CHF_AUTOIX[i],0)
        Vy0  = Vel(CHF_AUTOIX[i],1)

        UPi(CHF_AUTOIX[i],0) = Vx0*Pix(CHF_AUTOIX[i],0) + Vy0*Pix(CHF_AUTOIX[i],1)
        UPi(CHF_AUTOIX[i],1) = Vx0*Piy(CHF_AUTOIX[i],0) + Vy0*Piy(CHF_AUTOIX[i],1)

      endif

      CHF_ENDDO

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    COMPUTE CELL CENTER FLUXES

      subroutine cell_center_fluxes(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA1[eneDen],
     &     CHF_CONST_FRA[momDen],
     &     CHF_CONST_FRA[V],
     &     CHF_CONST_FRA1[P],
     &     CHF_FRA[rhoFlux],
     &     CHF_FRA[mxFlux],
     &     CHF_FRA[myFlux],
     &     CHF_FRA[mzFlux],
     &     CHF_FRA[enFlux]
     &     )

c     local variables
      integer n, CHF_AUTODECL[i]
      double precision norm0, norm1, norm2
      double precision Ptot

      do n=0, (CH_SPACEDIM-1)
      
         CHF_AUTOMULTIDO[gridbox;i]
   
            Ptot = P(CHF_AUTOIX[i])       
 
            rhoFlux(CHF_AUTOIX[i],n) = momDen(CHF_AUTOIX[i],n)
            mxFlux(CHF_AUTOIX[i],n) = momDen(CHF_AUTOIX[i],0)*V(CHF_AUTOIX[i],n)
            myFlux(CHF_AUTOIX[i],n) = momDen(CHF_AUTOIX[i],1)*V(CHF_AUTOIX[i],n)
 
            if (CH_SPACEDIM==3) then
               mzFlux(CHF_AUTOIX[i],n) = momDen(CHF_AUTOIX[i],2)*V(CHF_AUTOIX[i],n)
            endif
         
            if (n==0) then
               mxFlux(CHF_AUTOIX[i],n) = mxFlux(CHF_AUTOIX[i],n) + Ptot
            endif
            if (n==1) then
               myFlux(CHF_AUTOIX[i],n) = myFlux(CHF_AUTOIX[i],n) + Ptot
            endif
            if (n==2) then
               mzFlux(CHF_AUTOIX[i],n) = mzFlux(CHF_AUTOIX[i],n) + Ptot
            endif

            enFlux(CHF_AUTOIX[i],n) = (eneDen(CHF_AUTOIX[i]) + Ptot)
     &                                *V(CHF_AUTOIX[i],n)
            
         CHF_ENDDO

      enddo

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    COMPUTE CELL CENTER FLUXES

      subroutine cell_center_fluxes_twotemp(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA1[eneDeni],
     &     CHF_CONST_FRA1[eneDene],
     &     CHF_CONST_FRA[momDen],
     &     CHF_CONST_FRA[V],
     &     CHF_CONST_FRA1[Pion],
     &     CHF_CONST_FRA1[Pele],
     &     CHF_FRA[rhoFlux],
     &     CHF_FRA[mxFlux],
     &     CHF_FRA[myFlux],
     &     CHF_FRA[mzFlux],
     &     CHF_FRA[enFluxi],
     &     CHF_FRA[enFluxe]
     &     )

c     local variables
      integer n, CHF_AUTODECL[i]
      double precision norm0, norm1, norm2
      double precision Pi0, Pe0, Ptot

      do n=0, (CH_SPACEDIM-1)
      
         CHF_AUTOMULTIDO[gridbox;i]
   
            Pi0 = Pion(CHF_AUTOIX[i])       
            Pe0 = Pele(CHF_AUTOIX[i])       
            Ptot = Pi0+Pe0  
 
            rhoFlux(CHF_AUTOIX[i],n) = momDen(CHF_AUTOIX[i],n)
            mxFlux(CHF_AUTOIX[i],n) = momDen(CHF_AUTOIX[i],0)*V(CHF_AUTOIX[i],n)
            myFlux(CHF_AUTOIX[i],n) = momDen(CHF_AUTOIX[i],1)*V(CHF_AUTOIX[i],n)
 
            if (CH_SPACEDIM==3) then
               mzFlux(CHF_AUTOIX[i],n) = momDen(CHF_AUTOIX[i],2)*V(CHF_AUTOIX[i],n)
            endif
         
            if (n==0) then
               mxFlux(CHF_AUTOIX[i],n) = mxFlux(CHF_AUTOIX[i],n) + Ptot
            endif
            if (n==1) then
               myFlux(CHF_AUTOIX[i],n) = myFlux(CHF_AUTOIX[i],n) + Ptot
            endif
            if (n==2) then
               mzFlux(CHF_AUTOIX[i],n) = mzFlux(CHF_AUTOIX[i],n) + Ptot
            endif

            enFluxi(CHF_AUTOIX[i],n) = (eneDeni(CHF_AUTOIX[i]) + Pi0)
     &                                *V(CHF_AUTOIX[i],n)
            
            enFluxe(CHF_AUTOIX[i],n) = (eneDene(CHF_AUTOIX[i]) + Pe0)
     &                                *V(CHF_AUTOIX[i],n)

         CHF_ENDDO

      enddo

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    COMPUTE LAX FLUX SPLITTING

      subroutine lax_flux_splitting(
     &     CHF_BOX[gridbox],
     &     CHF_FRA[fluxL],
     &     CHF_FRA[fluxR],
     &     CHF_CONST_FRA[flux],
     &     CHF_CONST_FRA[C],
     &     CHF_CONST_FRA1[Jf]
     &     )

c     local variables
      integer n, CHF_AUTODECL[i]

      do n=0, (CHF_NCOMP[flux]-1)
      
         CHF_AUTOMULTIDO[gridbox;i]
          
            fluxL(CHF_AUTOIX[i],n) = 0.5*(flux(CHF_AUTOIX[i],n) - C(CHF_AUTOIX[i],n)*Jf(CHF_AUTOIX[i]))
            fluxR(CHF_AUTOIX[i],n) = 0.5*(flux(CHF_AUTOIX[i],n) + C(CHF_AUTOIX[i],n)*Jf(CHF_AUTOIX[i]))
 
         CHF_ENDDO

      enddo

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    CONVERT FLUX FROM PHYSICAL TO MAPPED

      subroutine convert_to_mapped(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA[physFlux],
     &     CHF_CONST_FRA[N],
c     &     CHF_CONST_FRA1[twoPiRmaj],
c     &     CHF_CONST_BOOL[twoDaxisymm],
     &     CHF_CONST_INT[Dims],
     &     CHF_FRA[mappedFlux]
     &     )

c     local variables
      integer CHF_AUTODECL[i]
      double precision mapped0, mapped1, mapped2

      CHF_AUTOMULTIDO[gridbox;i]

      if (Dims==3) then
        
        mapped0  = N(CHF_AUTOIX[i],0)*physFlux(CHF_AUTOIX[i],0) 
     &           + N(CHF_AUTOIX[i],3)*physFlux(CHF_AUTOIX[i],1)
     &           + N(CHF_AUTOIX[i],6)*physFlux(CHF_AUTOIX[i],2)
        mapped1  = N(CHF_AUTOIX[i],1)*physFlux(CHF_AUTOIX[i],0) 
     &           + N(CHF_AUTOIX[i],4)*physFlux(CHF_AUTOIX[i],1)
     &           + N(CHF_AUTOIX[i],7)*physFlux(CHF_AUTOIX[i],2)
        mapped2  = N(CHF_AUTOIX[i],3)*physFlux(CHF_AUTOIX[i],0) 
     &           + N(CHF_AUTOIX[i],5)*physFlux(CHF_AUTOIX[i],1)
     &           + N(CHF_AUTOIX[i],8)*physFlux(CHF_AUTOIX[i],2)
        
        mappedFlux(CHF_AUTOIX[i],0) = mapped0
        mappedFlux(CHF_AUTOIX[i],1) = mapped1
        mappedFlux(CHF_AUTOIX[i],2) = mapped2

      else 

        mapped0  = N(CHF_AUTOIX[i],0)*physFlux(CHF_AUTOIX[i],0) 
     &           + N(CHF_AUTOIX[i],2)*physFlux(CHF_AUTOIX[i],1)
        mapped1  = N(CHF_AUTOIX[i],1)*physFlux(CHF_AUTOIX[i],0) 
     &           + N(CHF_AUTOIX[i],3)*physFlux(CHF_AUTOIX[i],1)
c        print*, "shape(J)   = ", shape(J)
c        print*, "norm0    = ", norm0
c        print*, "CHF_AUTOIX[i]    = ", CHF_AUTOIX[i]
c        print*, "physFlux0    = ", physFlux(CHF_AUTOIX[i],0)
c        print*, "mappedFlux0  = ", mapped0
c        print*, "J    = ", J(CHF_AUTOIX[i])
c        print*, "J    = ", J(CHF_AUTOIX[i])

        mappedFlux(CHF_AUTOIX[i],0) = mapped0
        mappedFlux(CHF_AUTOIX[i],1) = mapped1

      endif

      CHF_ENDDO

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    ADVANCE E AND J USING RELAXATION SCHEME (BACKWARD EULER)

      subroutine advance_eandj_using_relax(
     &     CHF_BOX[edgebox],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_INT[method],
     &     CHF_CONST_REAL[dt],
     &     CHF_CONST_REAL[epsilon],
     &     CHF_CONST_REAL[delta],
     &     CHF_CONST_REAL[lambdai],
     &     CHF_CONST_FRA1[Eideal],
     &     CHF_CONST_FRA1[etaRes],
     &     CHF_CONST_FRA1[Ehall],
     &     CHF_CONST_FRA1[etaHall],
     &     CHF_CONST_FRA1[gfun],
     &     CHF_CONST_FRA1[gfunOp],
     &     CHF_CONST_FRA1[gradPe],
     &     CHF_CONST_FRA1[betaHall],
c     &     CHF_CONST_FRA1[divStress],
     &     CHF_CONST_FRA1[J0],
     &     CHF_CONST_FRA1[den],
     &     CHF_CONST_FRA1[Eold],
     &     CHF_CONST_FRA1[Jold],
     &     CHF_FRA1[Esoln],
     &     CHF_FRA1[Jsoln]
     &     )

c     local variables
      integer CHF_AUTODECL[i]
      double precision dtod, dtNoe, Eboltz, Estress, E0
      double precision alpha, wpedtsq, gfun0, gfun02, gfunOp0, dirSign, wlhdt
      double precision nudt, error
      double precision eta0, etamin, betaHallsq, gamma

      dtod = dt/delta
      etamin = 0.0e-4

      CHF_AUTOMULTIDO[edgebox;i]

        betaHallsq = betaHall(CHF_AUTOIX[i])**2
        betaHallsq = min(betaHallsq,0.9999)
        gamma = 1.0/sqrt(1-betaHallsq)

        dtNoe = dt*den(CHF_AUTOIX[i])/epsilon/gamma
        eta0 = etaRes(CHF_AUTOIX[i]) + etamin
        nudt = dtNoe*eta0
        wpedtsq = dtod*dtNoe
        alpha = 1.0 + wpedtsq + nudt
        dirSign = 1.0-2.0*dir
        wlhdt = dtNoe*etaHall(CHF_AUTOIX[i])*dirSign

        Eboltz = -lambdai*gradPe(CHF_AUTOIX[i])/den(CHF_AUTOIX[i])
c        Estress = divStress(CHF_AUTOIX[i])/den(CHF_AUTOIX[i])
        E0 = Eideal(CHF_AUTOIX[i]) + Ehall(CHF_AUTOIX[i]) + Eboltz
c     &     + Estress


        gfun0 = Jold(CHF_AUTOIX[i]) + wpedtsq*J0(CHF_AUTOIX[i])
     &        + dtNoe*(Eold(CHF_AUTOIX[i]) - Eideal(CHF_AUTOIX[i]) - Eboltz)
        gfun02 = gfun(CHF_AUTOIX[i])
        error = abs(gfun0-gfun02)
        gfunOp0 = gfunOp(CHF_AUTOIX[i])

      if(method.eq.two) then
         Jsoln(CHF_AUTOIX[i]) = J0(CHF_AUTOIX[i])
         Esoln(CHF_AUTOIX[i]) = E0
      else

      if(method.eq.zero) then
        Jsoln(CHF_AUTOIX[i]) = (gfun02 - dtNoe*Ehall(CHF_AUTOIX[i]))/alpha
      else
        Jsoln(CHF_AUTOIX[i]) = (alpha*gfun02 + wlhdt*gfunOp0)/(alpha*alpha + wlhdt*wlhdt)
      endif

        Esoln(CHF_AUTOIX[i]) = Eold(CHF_AUTOIX[i])
     &                       + dtod*( J0(CHF_AUTOIX[i]) - Jsoln(CHF_AUTOIX[i]) )

      endif

      if(error > 1.0e-15 ) then
c        print*, "CHF_AUTOIX[i] = ", CHF_AUTOIX[i]
c        print*, "dir = ", dir
c        print*, "Boxlo0 = ", iedgeBoxlo0
c        print*, "Boxhi0 = ", iedgeBoxhi0
c        print*, "Boxlo1 = ", iedgeBoxlo1
c        print*, "Boxhi1 = ", iedgeBoxhi1
c        print*, "error    = ", error
c        print*, "gfun0    = ", gfun0
c        print*, "gfun02   = ", gfun02
      endif
c        Esoln(CHF_AUTOIX[i]) = E0
c        Jsoln(CHF_AUTOIX[i]) = J0(CHF_AUTOIX[i])
c        print*, "CHF_AUTOIX[i]    = ", CHF_AUTOIX[i]
c        print*, "Eold(i,j)  = ", Eold(CHF_AUTOIX[i])
c        print*, "E0(i,j)    = ", E0
c        print*, "J0(i,j)    = ", J0(CHF_AUTOIX[i])
c        print*, "Jsoln(i,j) = ", Jsoln(CHF_AUTOIX[i])

      CHF_ENDDO

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

