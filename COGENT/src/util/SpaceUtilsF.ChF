C      _______              __
C     / ___/ /  ___  __ _  / /  ___
C    / /__/ _ \/ _ \/  V \/ _ \/ _ \
C    \___/_//_/\___/_/_/_/_.__/\___/
C    Please refer to Copyright.txt, in Chombo's root directory.

#include "CONSTANTS.H"

#define twentyseven (27.0d0)
#define fortyseven  (47.0d0)
#define eleven      (11.0d0)
#define thirteen    (13.0d0)
#define sixtieth    (1.0d0 / 60.0d0)

#define d0 (0.3d0)
#define d1 (0.6d0)
#define d2 (0.1d0)
#define thirteentwelfths (13.d0 / 12.d0)
#define quarter (0.25d0)

c ----------------------------------------------------------
c  limits face values based on Banks and Hittinger (2010) 
c  IEEE Transactions on Plasma Science 38(9), pp. 2198-2207.
c
c  facePhi <=> face-centered phi value
c  cellPhi  => cell-centered phi
c  faceVel  => normal velocity on faces
c  faceBox  =>
c  idir     =>
c  -------------------------------------------------------------
      subroutine BWENOFACE(CHF_FRA[facePhi],
     &                     CHF_CONST_FRA[cellPhi],
     &                     CHF_CONST_FRA1[faceVel],
     &                     CHF_BOX[faceBox],
     &                     CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T eps
      REAL_T fl,fr,bl,br,al,ar,wl,wr
      REAL_T c1l,c2l,c1r,c2r
      REAL_T wmax,wmin
      REAL_T onept5

      CHF_DTERM[
      ii = CHF_ID(idir, 0);
      jj = CHF_ID(idir, 1);
      kk = CHF_ID(idir, 2);
      ll = CHF_ID(idir, 3);
      mm = CHF_ID(idir, 4)]

      onept5 = one + half

c.....small parameter for mapping the weights
      eps = 1.d-6

      do n=0, (CHF_NCOMP[facePhi]-1)
        
         if(CHF_NCOMP[facePhi].lt.CHF_NCOMP[cellPhi]) then
            ncell = idir
         else 
            ncell = n
         endif

         CHF_MULTIDO[faceBox;i;j;k;l;m]

c.......get left and right 3rd order approximations
        fl = sixth*(
     &             - cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
     &             + five*cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &             + two*cellPhi(CHF_IX[i;j;k;l;m],ncell) )
        fr = sixth*(
     &               two*cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &             + five*cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &             - cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell) )

c.......get smoothness indicators
        c1l = ( cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &        - two*cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &        + cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell) )
        c2l = ( cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &        - cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell) )
        c1r = ( cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell)
     &        - two*cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &        + cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell) )
        c2r = ( cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell)
     &        - cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell) )
        bl  = four*(c1l**2)*third+half*c1l*c2l+fourth*c2l**2
        br  = four*(c1r**2)*third-half*c1r*c2r+fourth*c2r**2

c.......get weights
        al = one/((eps+bl)**2)
        ar = one/((eps+br)**2)
        wl = al/(al+ar)
        wr = ar/(al+ar)

c.......perform mapping of the weights (mapped weno as in Henrick JCP 2005)
        al = wl*(three*fourth+wl*(wl-onept5))
        ar = wr*(three*fourth+wr*(wr-onept5))
        wl = al/(al+ar)
        wr = ar/(al+ar)

        wmax = max(wl,wr)
        wmin = min(wl,wr)
        if( faceVel(CHF_IX[i;j;k;l;m]).gt.zero ) then
          wl = wmax
          wr = wmin
        else
          wl = wmin
          wr = wmax
        end if

c.......assign face value
        facePhi(CHF_IX[i;j;k;l;m],n) = ( wl*fl + wr*fr )

        CHF_ENDDO
      enddo

      return
      end


c      function g( w, d )
c      REAL_T g, w, d
c      g = (d*(1-w)+(w-d)**2)/(d**2+w*(1-two*d))
c      return
c      end
      
c ----------------------------------------------------------
c  limits face values based on WENO 5
c
c  facePhi <=> face-centered phi value
c  cellPhi  => cell-centered phi
c  faceVel  => normal velocity on faces
c  faceBox  =>
c  idir     =>
c  -------------------------------------------------------------
      subroutine WENO5FACE(CHF_FRA[facePhi],
     &                     CHF_CONST_FRA[cellPhi],
     &                     CHF_CONST_FRA1[faceVel],
     &                     CHF_CONST_FRA[smoothFn],
     &                     CHF_BOX[faceBox],
     &                     CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T eps
      REAL_T fl,fr,bl,br,al,ar,wl,wr
      REAL_T c0,c1,c2,c3
      REAL_T a0,a1,a2,asuminv
      REAL_T b0,b1,b2
      REAL_T v0,v1,v2
      REAL_T w0,w1,w2
      REAL_T g

      CHF_DTERM[
      ii = CHF_ID(idir, 0);
      jj = CHF_ID(idir, 1);
      kk = CHF_ID(idir, 2);
      ll = CHF_ID(idir, 3);
      mm = CHF_ID(idir, 4)]

c.....small parameter for mapping the weights
      eps = 1.d-6
c      eps = 1.d-26

      do n=0, (CHF_NCOMP[facePhi]-1)
        
         if(CHF_NCOMP[facePhi].lt.CHF_NCOMP[cellPhi]) then
            ncell = idir
         else 
            ncell = n
         endif

         CHF_MULTIDO[faceBox;i;j;k;l;m]

c.......get left, center, and right 3rd order approximations
        if( faceVel(CHF_IX[i;j;k;l;m]).gt.zero ) then

          v0 = sixth*(
     &                 two*cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &               + five*cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &               - cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell) )
          v1 = sixth*(
     &               - cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
     &               + five*cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &               + two*cellPhi(CHF_IX[i;j;k;l;m],ncell) )
          v2 = sixth*(
     &                 two*cellPhi(CHF_IX[i-3*ii;j-3*jj;k-3*kk;l-3*ll;m-3*mm],ncell)
     &               - seven*cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
     &               + eleven*cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell) )

          c0 = cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell)
     &       - cellPhi(CHF_IX[i;j;k;l;m],ncell)
          c1 = cellPhi(CHF_IX[i;j;k;l;m],ncell) 
     &       - cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell) 
          c2 = cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell) 
     &       - cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
          c3 = cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
     &       - cellPhi(CHF_IX[i-3*ii;j-3*jj;k-3*kk;l-3*ll;m-3*mm],ncell) 

        else

          v0 = sixth*(
     &                 two*cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &               + five*cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &               - cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell) )
          v1 = sixth*(
     &               - cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell) 
     &               + five*cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &               + two*cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell) )
          v2 = sixth*(
     &                 two*cellPhi(CHF_IX[i+2*ii;j+2*jj;k+2*kk;l+2*ll;m+2*mm],ncell)
     &               - seven*cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell)
     &               + eleven*cellPhi(CHF_IX[i;j;k;l;m],ncell) )

          c0 = cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
     &       - cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
          c1 = cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell) 
     &       - cellPhi(CHF_IX[i;j;k;l;m],ncell) 
          c2 = cellPhi(CHF_IX[i;j;k;l;m],ncell) 
     &       - cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell)
          c3 = cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell)
     &       - cellPhi(CHF_IX[i+2*ii;j+2*jj;k+2*kk;l+2*ll;m+2*mm],ncell)

        end if

c.......get smoothness indicators
        b0 = thirteentwelfths*(c1-c0)**2+quarter*(three*c1-c0)**2
        b1 = thirteentwelfths*(c2-c1)**2+quarter*(c2+c1)**2
        b2 = thirteentwelfths*(c3-c2)**2+quarter*(c3-three*c2)**2

c.......get weights
        a0 = d0/((eps*smoothFn(CHF_IX[i;j;k;l;m],idir) + b0)**2)
        a1 = d1/((eps*smoothFn(CHF_IX[i;j;k;l;m],idir) + b1)**2)
        a2 = d2/((eps*smoothFn(CHF_IX[i;j;k;l;m],idir) + b2)**2)
c        a0 = d0/((eps + b0)**2)
c        a1 = d1/((eps + b1)**2)
c        a2 = d2/((eps + b2)**2)

        asuminv = one/(a0+a1+a2)
        w0 = a0*asuminv
        w1 = a1*asuminv
        w2 = a2*asuminv

c.......perform mapping of the weights (mapped weno as in Henrik JCP 2005)
c        a0 = g(w0,d0)
c        a1 = g(w1,d1)
c        a2 = g(w2,d2)

c        asuminv = one/(a0+a1+a2)
c        w0 = a0 * asuminv
c        w1 = a1 * asuminv
c        w2 = a2 * asuminv

c.......assign face value
        facePhi(CHF_IX[i;j;k;l;m],n) = ( w0*v0 + w1*v1 + w2*v2 )

        CHF_ENDDO
      enddo

      return
      end

c --------------------------------------------------------------
c  average face values based 2nd-order TVD upwind
c
c  facePhi <=> face-centered phi value
c  cellPhi  => cell-centered phi
c  faceVel  => normal velocity on faces
c  faceBox  =>
c  idir     =>
c  -------------------------------------------------------------
      subroutine TVDFACE( CHF_FRA[facePhi],
     &                    CHF_CONST_FRA[cellPhi],
     &                    CHF_CONST_FRA1[faceVel],
     &                    CHF_BOX[faceBox],
     &                    CHF_CONST_INT[limiter],
     &                    CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val1st, val2nd, val, DeltaFluxL, DeltaFluxR

      CHF_DTERM[
      ii = CHF_ID(idir, 0);
      jj = CHF_ID(idir, 1);
      kk = CHF_ID(idir, 2);
      ll = CHF_ID(idir, 3);
      mm = CHF_ID(idir, 4)]

      do n=0, (CHF_NCOMP[facePhi]-1)
        
        if(CHF_NCOMP[facePhi].lt.CHF_NCOMP[cellPhi]) then
           ncell = idir
        else 
           ncell = n
        endif

        CHF_MULTIDO[faceBox;i;j;k;l;m]

c.............compute 1st-order flux and 2nd-order delta fluxes
        if( faceVel(CHF_IX[i;j;k;l;m]).gt.zero ) then
          val1st = cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
          DeltaFluxL = half*cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &               - half*cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
          DeltaFluxR = half*cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &               - half*cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
        else
          val1st = cellPhi(CHF_IX[i;j;k;l;m],ncell)
          DeltaFluxL = -half*cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &               +  half*cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
          DeltaFluxR = -half*cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell)
     &               +  half*cellPhi(CHF_IX[i;j;k;l;m],ncell)
        end if

c.............get second order correction using flux limiters
        if(limiter==1) then
c.............vanleer limiter
          if ( (DeltaFluxL.gt.zero .and. DeltaFluxR.gt.zero) .or. 
     &         (DeltaFluxL.lt.zero .and. DeltaFluxR.lt.zero) ) then
            val2nd = two*DeltaFluxL*DeltaFluxR/(DeltaFluxL+DeltaFluxR)
          else
            val2nd = zero
          end if
        else if(limiter==2) then
c.............minmod limiter
          if (DeltaFluxL.gt.zero .and. DeltaFluxR.gt.zero) then
            val2nd = min(DeltaFluxL,DeltaFluxR) 
          else if (DeltaFluxL.lt.zero .and. DeltaFluxR.lt.zero) then
            val2nd = max(DeltaFluxL,DeltaFluxR) 
          else
            val2nd = zero
          end if
        else if(limiter==3) then
c.............superbee
          if (abs(DeltaFluxL).ge.abs(DeltaFluxR)) then
            DeltaFluxR = two*DeltaFluxR
          else
            DeltaFluxL = two*DeltaFluxL
          end if

          if (DeltaFluxL.gt.zero .and. DeltaFluxR.gt.zero) then
            val2nd = min(DeltaFluxL,DeltaFluxR) 
          else if (DeltaFluxL.lt.zero .and. DeltaFluxR.lt.zero) then
            val2nd = max(DeltaFluxL,DeltaFluxR) 
          else
            val2nd = zero
          end if
c.............no limiter
        else
          val2nd = zero
        end if

c.......assign face value
        facePhi(CHF_IX[i;j;k;l;m],n) = val1st + val2nd

        CHF_ENDDO
      enddo

      return
      end

c --------------------------------------------------------------
c  average face values based linear, 1st-order upwind
c
c  facePhi <=> face-centered phi value
c  cellPhi  => cell-centered phi
c  faceVel  => normal velocity on faces
c  faceBox  =>
c  idir     =>
c  -------------------------------------------------------------
      subroutine UW1FACE( CHF_FRA[facePhi],
     &                    CHF_CONST_FRA[cellPhi],
     &                    CHF_CONST_FRA1[faceVel],
     &                    CHF_BOX[faceBox],
     &                    CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val

      CHF_DTERM[
      ii = CHF_ID(idir, 0);
      jj = CHF_ID(idir, 1);
      kk = CHF_ID(idir, 2);
      ll = CHF_ID(idir, 3);
      mm = CHF_ID(idir, 4)]

      do n=0, (CHF_NCOMP[facePhi]-1)
        
        if(CHF_NCOMP[facePhi].lt.CHF_NCOMP[cellPhi]) then
           ncell = idir
        else 
           ncell = n
        endif

        CHF_MULTIDO[faceBox;i;j;k;l;m]

        if( faceVel(CHF_IX[i;j;k;l;m]).gt.zero ) then
          val = cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
        else
          val = cellPhi(CHF_IX[i;j;k;l;m],ncell)
        end if

c.......assign face value
        facePhi(CHF_IX[i;j;k;l;m],n) = val

        CHF_ENDDO
      enddo

      return
      end

c --------------------------------------------------------------
c  average face values based linear, 1st-order upwind
c  and c2 with flux limiter
c
c  facePhi <=> face-centered phi value
c  cellPhi  => cell-centered phi
c  faceVel  => normal velocity on faces
c  faceBox  =>
c  idir     =>
c  -------------------------------------------------------------
      subroutine UW1C2FACE( CHF_FRA[facePhi],
     &                      CHF_CONST_FRA[cellPhi],
     &                      CHF_CONST_FRA[cellFun],
     &                      CHF_CONST_FRA1[faceVel],
     &                      CHF_BOX[faceBox],
     &                      CHF_CONST_INT[limType],
     &                      CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val, valUW1, valC2, numer, denom, rlim, lim0, lim1, limiter

      limiter = 1.0

      CHF_DTERM[
      ii = CHF_ID(idir, 0);
      jj = CHF_ID(idir, 1);
      kk = CHF_ID(idir, 2);
      ll = CHF_ID(idir, 3);
      mm = CHF_ID(idir, 4)]

      do n=0, (CHF_NCOMP[facePhi]-1)
        
        if(CHF_NCOMP[facePhi].lt.CHF_NCOMP[cellPhi]) then
           ncell = idir
        else 
           ncell = n
        endif

        CHF_MULTIDO[faceBox;i;j;k;l;m]

           numer = cellFun(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &           - cellFun(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
           denom = cellFun(CHF_IX[i;j;k;l;m],ncell)
     &           - cellFun(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)

           if( denom.eq.zero ) then 
              rlim = 1000.0
           else          
              rlim = numer/denom
           end if

           if( limType.eq.0 ) then
c.............no limiter => uw1 scheme
              limiter = 0.0
           else if( limType.eq.1) then
c.............van Leer limiter
              limiter = (rlim + abs(rlim))/(1.0 + abs(rlim))
           else if( limType.eq.2) then
c.............minmod limiter
              limiter = min(1.0,rlim)
           else if( limType.eq.3) then
c.............superbee limiter
              lim0 = min(rlim,2.0)
              lim1 = min(2.0*rlim,1.0)
              limiter = max(lim0,lim1)
           else if( limType.eq.4) then
c.............van Albada 1 limiter
              limiter = (rlim*rlim + rlim)/(rlim*rlim + 1.0)
           else if( limType.eq.5) then
c.............van Albada 2 limiter
              limiter = (2.0*rlim)/(rlim*rlim + 1.0)
           else
c............. no upwind => c2 scheme
              limiter = 1.0
           end if
           limiter = max(0.0,limiter)
 
c           if( limiter.lt.zero .or. limiter.gt.one ) then
c        print*, "rlim    = ", rlim
c        print*, "limiter = ", limiter
c           end if
c        print*, "limType  = ", limType

           valC2 = half*( cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &           +        cellPhi(CHF_IX[i;j;k;l;m],ncell) )

           if( faceVel(CHF_IX[i;j;k;l;m]).gt.zero ) then
              valUW1 = cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
           else
              valUW1 = cellPhi(CHF_IX[i;j;k;l;m],ncell)
           end if

c.......assign face value
           facePhi(CHF_IX[i;j;k;l;m],n) = valUW1 + limiter*(valC2 - valUW1);

        CHF_ENDDO
      enddo

      return
      end

c ----------------------------------------------------------
c  average face values based linear, 3rd-order upwind
c
c  facePhi <=> face-centered phi value
c  cellPhi  => cell-centered phi
c  faceVel  => normal velocity on faces
c  faceBox  =>
c  idir     =>
c  -------------------------------------------------------------
      subroutine UW3FACE(CHF_FRA[facePhi],
     &                   CHF_CONST_FRA[cellPhi],
     &                   CHF_CONST_FRA1[faceVel],
     &                   CHF_BOX[faceBox],
     &                   CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val

      CHF_DTERM[
      ii = CHF_ID(idir, 0);
      jj = CHF_ID(idir, 1);
      kk = CHF_ID(idir, 2);
      ll = CHF_ID(idir, 3);
      mm = CHF_ID(idir, 4)]

      do n=0, (CHF_NCOMP[facePhi]-1)
         
        if(CHF_NCOMP[facePhi].lt.CHF_NCOMP[cellPhi]) then
           ncell = idir
        else 
           ncell = n
        endif

        CHF_MULTIDO[faceBox;i;j;k;l;m]

        if( faceVel(CHF_IX[i;j;k;l;m]).gt.zero ) then
          val = - one         
     &          * cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
     &        + five    
     &          * cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &        + two
     &          * cellPhi(CHF_IX[i;j;k;l;m],ncell)
        else
          val = - one         
     &          * cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell)
     &        + five  
     &          * cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &        + two
     &          * cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
        end if

c.......assign face value
        facePhi(CHF_IX[i;j;k;l;m],n) = val * sixth

        CHF_ENDDO
      enddo

      return 
      end


c ----------------------------------------------------------
c  average face values based linear, 5th-order upwind
c
c  facePhi <=> face-centered phi value
c  cellPhi  => cell-centered phi
c  faceVel  => normal velocity on faces
c  faceBox  =>
c  idir     =>
c  -------------------------------------------------------------
      subroutine UW5FACE(CHF_FRA[facePhi],
     &                   CHF_CONST_FRA[cellPhi],
     &                   CHF_CONST_FRA1[faceVel],
     &                   CHF_BOX[faceBox],
     &                   CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val

      CHF_DTERM[
      ii = CHF_ID(idir, 0);
      jj = CHF_ID(idir, 1);
      kk = CHF_ID(idir, 2);
      ll = CHF_ID(idir, 3);
      mm = CHF_ID(idir, 4)]

      do n=0, (CHF_NCOMP[facePhi]-1)
        
         if(CHF_NCOMP[facePhi].lt.CHF_NCOMP[cellPhi]) then
            ncell = idir
         else 
            ncell = n
         endif

         CHF_MULTIDO[faceBox;i;j;k;l;m]

        if( faceVel(CHF_IX[i;j;k;l;m]).gt.zero ) then
          val = two
     &          * cellPhi(CHF_IX[i-3*ii;j-3*jj;k-3*kk;l-3*ll;m-3*mm],ncell)
     &        - thirteen
     &          * cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
     &        + fortyseven
     &          * cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &        + twentyseven
     &          * cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &        - three
     &          * cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell)
        else
          val = two
     &          * cellPhi(CHF_IX[i+2*ii;j+2*jj;k+2*kk;l+2*ll;m+2*mm],ncell)
     &        - thirteen
     &          * cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell)
     &        + fortyseven
     &          * cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &        + twentyseven
     &          * cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &        - three
     &          * cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
         end if

c.......assign face value
        facePhi(CHF_IX[i;j;k;l;m],n) = val * sixtieth

        CHF_ENDDO
      enddo

      return
      end


c ----------------------------------------------------------
c  average face values based QUICK method
c
c  facePhi <=> face-centered phi value
c  cellPhi  => cell-centered phi
c  faceVel  => normal velocity on faces
c  faceBox  =>
c  idir     =>
c  -------------------------------------------------------------
      subroutine QUICKFACE(CHF_FRA[facePhi],
     &                     CHF_CONST_FRA[cellPhi],
     &                     CHF_CONST_FRA1[faceVel],
     &                     CHF_BOX[faceBox],
     &                     CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val

      CHF_DTERM[
      ii = CHF_ID(idir, 0);
      jj = CHF_ID(idir, 1);
      kk = CHF_ID(idir, 2);
      ll = CHF_ID(idir, 3);
      mm = CHF_ID(idir, 4)]

      do n=0, (CHF_NCOMP[facePhi]-1)
        
        if(CHF_NCOMP[facePhi].lt.CHF_NCOMP[cellPhi]) then
           ncell = idir
        else 
           ncell = n
        endif

        CHF_MULTIDO[faceBox;i;j;k;l;m]

        if( faceVel(CHF_IX[i;j;k;l;m]).gt.zero ) then
          val = - one         
     &          * cellPhi(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm],ncell)
     &        + six    
     &          * cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &        + three
     &          * cellPhi(CHF_IX[i;j;k;l;m],ncell)
        else
          val = - one         
     &          * cellPhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],ncell)
     &        + six  
     &          * cellPhi(CHF_IX[i;j;k;l;m],ncell)
     &        + three
     &          * cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
        end if

c.......assign face value
        facePhi(CHF_IX[i;j;k;l;m],n) = val * eighth

        CHF_ENDDO
      enddo

      return
      end

c ----------------------------------------------------------
c  interp face center value to cell center using C2 method
c
c  -------------------------------------------------------------
      subroutine C2FACETOCELL(CHF_BOX[cellBox],
     &                        CHF_CONST_INT[dir],
     &                        CHF_CONST_FRA1[facePhi],
     &                        CHF_FRA1[cellPhi])

      integer CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val

      CHF_DTERM[
      ii = CHF_ID(dir, 0);
      jj = CHF_ID(dir, 1);
      kk = CHF_ID(dir, 2);
      ll = CHF_ID(dir, 3);
      mm = CHF_ID(dir, 4)]

      CHF_MULTIDO[cellBox;i;j;k;l;m]

         val = facePhi(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm])
     &       + facePhi(CHF_IX[i;j;k;l;m])

         cellPhi(CHF_IX[i;j;k;l;m]) = val * half

      CHF_ENDDO

      return
      end

c  -------------------------------------------------------------
c
c  interp cell face scalar values to cell center using C2 method
c
c  -------------------------------------------------------------
      subroutine FACE_SCALAR_TO_CELL( CHF_BOX[cellBox],
     &                                CHF_CONST_INT[dir],
     &                                CHF_CONST_FRA[facePhi],
     &                                CHF_FRA[cellPhi] )

      integer comp, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val

      CHF_DTERM[
      ii = CHF_ID(dir, 0);
      jj = CHF_ID(dir, 1);
      kk = 0;
      ll = 0;
      mm = 0]

      CHF_MULTIDO[cellBox;i;j;k;l;m]

         do comp = 0, (CHF_NCOMP[cellPhi]-1)
            val = half*( facePhi(CHF_IX[i+ii;j+jj;k;l;m],comp)
     &          +        facePhi(CHF_IX[i;j;k;l;m],comp) )
            cellPhi(CHF_IX[i;j;k;l;m],comp) = (cellPhi(CHF_IX[i;j;k;l;m],comp) + val)/(dir+1.0)
         enddo

      CHF_ENDDO

      return
      end

c ------------------------------------------------------------------
c
c  interp cell edge values from one edge to another using C2 method
c
c  -----------------------------------------------------------------
      subroutine C2_EDGES_TO_EDGES( CHF_BOX[edgeBox], 
     &                              CHF_CONST_FRA1[Ein],
     &                              CHF_FRA1[Eout],
     &                              CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      integer CHF_DDECL[ii0;jj0;kk0;ll0;mm0]
      REAL_T val_up, val_down

      CHF_DTERM[
      ii = 1 - CHF_ID(idir, 0);
      jj = 1 - CHF_ID(idir, 1);
      kk = 1 - CHF_ID(idir, 2);
      ll = 1 - CHF_ID(idir, 3);
      mm = 1 - CHF_ID(idir, 4)]
      
      CHF_DTERM[
      ii0 = CHF_ID(idir, 0);
      jj0 = CHF_ID(idir, 1);
      kk0 = CHF_ID(idir, 2);
      ll0 = CHF_ID(idir, 3);
      mm0 = CHF_ID(idir, 4)]

      CHF_MULTIDO[edgeBox;i;j;k;l;m]

c        interp to cell on one side of idir
         val_up = Ein(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm])
     &          + Ein(CHF_IX[i;j;k;l;m])
         val_up = val_up * half
         
c        interp to cell on other side of idir
         val_down = Ein(CHF_IX[i-ii+ii0;j-jj+jj0;k-kk+kk0;l-ll+ll0;m-mm+mm0])
     &            + Ein(CHF_IX[i+ii0;j+jj0;k+kk0;l+ll0;m+mm0])
         val_down = val_down * half

         Eout(CHF_IX[i;j;k;l;m]) = ( val_down + val_up ) * half

      CHF_ENDDO

      return
      end

c --------------------------------------------------------------
c
c  interp cell node values to cell edge values using C2 method
c
c  -------------------------------------------------------------

      subroutine C2_NODES_TO_EDGES( CHF_BOX[edgeBox], 
     &                              CHF_CONST_INT[dir],
     &                              CHF_CONST_FRA[ncFin],
     &                              CHF_FRA[ecFout] )


      integer comp, n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T valUp, valDown

      CHF_DTERM[
      ii = CHF_ID(dir, 0);
      jj = CHF_ID(dir, 1);
      kk = CHF_ID(dir, 2);
      ll = CHF_ID(dir, 3);
      mm = CHF_ID(dir, 4)]
      
      CHF_MULTIDO[edgeBox;i;j;k;l;m]
          
         do comp = 0, (CHF_NCOMP[ecFout]-1)

            valUp   = ncFin(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm],comp)
            valDown = ncFin(CHF_IX[i;j;k;l;m],comp)
            ecFout(CHF_IX[i;j;k;l;m],comp) = ( valUp + valDown ) * half

         enddo

      CHF_ENDDO

      return
      end

c --------------------------------------------------------------
c
c  interp cell node values to cell center values using C2 method
c
c  -------------------------------------------------------------

      subroutine C2_NODES_TO_CELLS( CHF_BOX[cellBox], 
     &                              CHF_CONST_FRA[ncFin],
     &                              CHF_FRA[ccFout] )


      integer comp, n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val00, val01, val10, val11

      CHF_MULTIDO[cellBox;i;j;k;l;m]
          
         do comp = 0, (CHF_NCOMP[ccFout]-1)

            val11 = ncFin(CHF_IX[i+1;j+1;k;l;m],comp)
            val10 = ncFin(CHF_IX[i+1;j;k;l;m],comp)
            val01 = ncFin(CHF_IX[i;j+1;k;l;m],comp)
            val00 = ncFin(CHF_IX[i;j;k;l;m],comp)
            ccFout(CHF_IX[i;j;k;l;m],comp) = ( val00 + val01 + val10 + val11 ) / four

         enddo

      CHF_ENDDO

      return
      end

c --------------------------------------------------------------
c
c  interp cell center values to cell node values using C2 method
c
c  -------------------------------------------------------------

      subroutine C2_CELLS_TO_NODES( CHF_BOX[nodeBox], 
     &                              CHF_CONST_FRA[ccFin],
     &                              CHF_FRA[ncFout] )


      integer comp, n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val00, val01, val10, val11

      CHF_MULTIDO[nodeBox;i;j;k;l;m]
          
         do comp = 0, (CHF_NCOMP[ncFout]-1)

            val11 = ccFin(CHF_IX[i;j;k;l;m],comp)
            val10 = ccFin(CHF_IX[i-1;j;k;l;m],comp)
            val01 = ccFin(CHF_IX[i;j-1;k;l;m],comp)
            val00 = ccFin(CHF_IX[i-1;j-1;k;l;m],comp)
            ncFout(CHF_IX[i;j;k;l;m],comp) = ( val00 + val01 + val10 + val11 ) / four

         enddo

      CHF_ENDDO

      return
      end

c --------------------------------------------------------------
c
c  compute dir derivative of cell edge values using C2 method
c
c -------------------------------------------------------------

      subroutine EDGE_GRAD_AT_CELLS(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_REAL[dX],
     &     CHF_CONST_FRA1[PhiOnEdges],
     &     CHF_FRA1[gradPhi] )
      
      integer CHF_DDECL[i;j;k;l;m] 
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      double precision edgePhi_up, edgePhi_down      

      CHF_DTERM[
      ii = CHF_ID(dir, 0);
      jj = CHF_ID(dir, 1);
      kk = 0;
      ll = 0;
      mm = 0]

      CHF_MULTIDO[box;i;j;k;l;m]
      
         edgePhi_down = PhiOnEdges(CHF_IX[i;j;k;l;m])
         edgePhi_up   = PhiOnEdges(CHF_IX[i+ii;j+jj;k;l;m])
           
         gradPhi(CHF_IX[i;j;k;l;m]) = (edgePhi_up - edgePhi_down)/dX

      CHF_ENDDO

      return
      end

c --------------------------------------------------------------
c
c  compute dir derivative of cell edge values using C2 method
c
c -------------------------------------------------------------

      subroutine EDGE_GRAD_AT_NODES(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_REAL[dX],
     &     CHF_CONST_FRA1[PhiOnEdges],
     &     CHF_FRA1[gradPhi] )
      
      integer CHF_DDECL[i;j;k;l;m] 
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      double precision edgePhi_up, edgePhi_down      

      CHF_DTERM[
      ii = CHF_ID(dir, 0);
      jj = CHF_ID(dir, 1);
      kk = 0;
      ll = 0;
      mm = 0]

      CHF_MULTIDO[box;i;j;k;l;m]
      
         edgePhi_down = PhiOnEdges(CHF_IX[i-ii;j-jj;k;l;m])
         edgePhi_up   = PhiOnEdges(CHF_IX[i;j;k;l;m])
           
         gradPhi(CHF_IX[i;j;k;l;m]) = (edgePhi_up - edgePhi_down)/dX

      CHF_ENDDO

      return
      end

c ----------------------------------------------------------
c  interp cell edge values to cell center using C2 method
c
c  -------------------------------------------------------------
      subroutine C2CELL(CHF_BOX[cellBox],
     &                  CHF_CONST_INT[dir],
     &                  CHF_CONST_FRA1[edgePhi],
     &                  CHF_FRA1[cellPhi])

      integer CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val

      CHF_DTERM[
      ii = 1 - CHF_ID(dir, 0);
      jj = 1 - CHF_ID(dir, 1);
      kk = 0;
      ll = 0;
      mm = 0]

      CHF_MULTIDO[cellBox;i;j;k;l;m]

         val = edgePhi(CHF_IX[i+ii;j+jj;k;l;m])
     &       + edgePhi(CHF_IX[i;j;k;l;m])

         cellPhi(CHF_IX[i;j;k;l;m]) = val * half

      CHF_ENDDO

      return
      end

c  -------------------------------------------------------------
c
c  interp cell edge scalar values to cell center using C2 method
c
c  -------------------------------------------------------------
      subroutine EDGE_SCALAR_TO_CELL( CHF_BOX[cellBox],
     &                                CHF_CONST_INT[dir],
     &                                CHF_CONST_FRA[edgePhi],
     &                                CHF_FRA[cellPhi] )

      integer comp, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val

      CHF_DTERM[
      ii = 1-CHF_ID(dir, 0);
      jj = 1-CHF_ID(dir, 1);
      kk = 0;
      ll = 0;
      mm = 0]

      CHF_MULTIDO[cellBox;i;j;k;l;m]

         do comp = 0, (CHF_NCOMP[cellPhi]-1)
            val = half*( edgePhi(CHF_IX[i+ii;j+jj;k;l;m],comp)
     &          +        edgePhi(CHF_IX[i;j;k;l;m],comp) )
            cellPhi(CHF_IX[i;j;k;l;m],comp) = (cellPhi(CHF_IX[i;j;k;l;m],comp) + val)/(dir+1.0)
c            cellPhi(CHF_IX[i;j;k;l;m],comp) = (cellPhi(CHF_IX[i;j;k;l;m],comp) + val)
c            cellPhi(CHF_IX[i;j;k;l;m],comp) = edgePhi(CHF_IX[i+ii;j+jj;k;l;m],comp)
c            if(dir==0) cellPhi(CHF_IX[i;j;k;l;m],comp) = val
         enddo

      CHF_ENDDO

      return
      end

c ----------------------------------------------------------
c  interp cell center values to cell edges based C2 method
c
c  -------------------------------------------------------------
      subroutine C2EDGE(CHF_FRA[edgePhi],
     &                  CHF_CONST_FRA[cellPhi],
     &                  CHF_BOX[edgeBox],
     &                  CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val

      CHF_DTERM[
      ii = 1 - CHF_ID(idir, 0);
      jj = 1 - CHF_ID(idir, 1);
      kk = 1 - CHF_ID(idir, 2);
      ll = 1 - CHF_ID(idir, 3);
      mm = 1 - CHF_ID(idir, 4)]

      do n=0, (CHF_NCOMP[edgePhi]-1)

         if(CHF_NCOMP[edgePhi].lt.CHF_NCOMP[cellPhi]) then
            ncell = idir
         else 
            ncell = n
         endif

         CHF_MULTIDO[edgeBox;i;j;k;l;m]

            val = cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &          + cellPhi(CHF_IX[i;j;k;l;m],ncell)

            edgePhi(CHF_IX[i;j;k;l;m],n) = val * half

         CHF_ENDDO
      enddo

      return
      end

c ----------------------------------------------------------
c  interp cell center values to cell edges based U1 method
c
c  -------------------------------------------------------------
      subroutine UW1EDGE(CHF_FRA[edgePhi],
     &                   CHF_CONST_FRA[cellPhi],
     &                   CHF_CONST_FRA1[faceVel],
     &                   CHF_BOX[edgeBox],
     &                   CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val

      CHF_DTERM[
      ii = 1 - CHF_ID(idir, 0);
      jj = 1 - CHF_ID(idir, 1);
      kk = 1 - CHF_ID(idir, 2);
      ll = 1 - CHF_ID(idir, 3);
      mm = 1 - CHF_ID(idir, 4)]

      do n=0, (CHF_NCOMP[edgePhi]-1)

         if(CHF_NCOMP[edgePhi].lt.CHF_NCOMP[cellPhi]) then
            ncell = idir
         else 
            ncell = n
         endif

         CHF_MULTIDO[edgeBox;i;j;k;l;m]

         if( faceVel(CHF_IX[i;j;k;l;m]).gt.zero ) then
            val = cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
         else
            val = cellPhi(CHF_IX[i;j;k;l;m],ncell)
         end if

            edgePhi(CHF_IX[i;j;k;l;m],n) = val

         CHF_ENDDO
      enddo

      return
      end


c ----------------------------------------------------------
c  average face values based C2 method
c
c  facePhi <=> face-centered phi value
c  cellPhi  => cell-centered phi
c  faceBox  =>
c  idir     =>
c  -------------------------------------------------------------
      subroutine C2FACE(CHF_FRA[facePhi],
     &                  CHF_CONST_FRA[cellPhi],
     &                  CHF_BOX[faceBox],
     &                  CHF_CONST_INT[idir] )


      integer n, ncell, CHF_DDECL[i;j;k;l;m]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      REAL_T val

      CHF_DTERM[
      ii = CHF_ID(idir, 0);
      jj = CHF_ID(idir, 1);
      kk = CHF_ID(idir, 2);
      ll = CHF_ID(idir, 3);
      mm = CHF_ID(idir, 4)]

      do n=0, (CHF_NCOMP[facePhi]-1)

        if(CHF_NCOMP[facePhi].lt.CHF_NCOMP[cellPhi]) then
           ncell = idir
        else 
           ncell = n
        endif

        CHF_MULTIDO[faceBox;i;j;k;l;m]

          val = cellPhi(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm],ncell)
     &        + cellPhi(CHF_IX[i;j;k;l;m],ncell)

c.......assign face value
        facePhi(CHF_IX[i;j;k;l;m],n) = val * half

        CHF_ENDDO
      enddo

      return
      end

c ----------------------------------------------------------

      subroutine extrap_for_cc_ops(
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_INT[side],
     &     CHF_CONST_INT[order],
     &     CHF_BOX[facebox],
     &     CHF_BOX[interiorbox],
     &     CHF_FRA[array]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k;l;m;n]
      integer CHF_DDECL[id;jd;kd;ld;md;nd]
      integer CHF_DDECL[ni;nj;nk;nl;nm;nn]
      integer p, q, comp, ncomp
      double precision sum, coef2(0:2,2), coef4(0:4,3)
      data coef2 /  3.d0, -3.d0, 1.d0,
     &             6.d0, -8.d0, 3.d0 /
      data coef4 /  5.d0,  -10.d0,  10.d0,  -5.d0,  1.d0,
     &            15.d0,  -40.d0,  45.d0, -24.d0,  5.d0,
     &            35.d0, -105.d0, 126.d0, -70.d0, 15.d0 /

c
c     If order = 2, this routine second-order extrapolates to at most two ghost cells
c     If order = 4, this routine fourth-order extrapolates to at most three ghost cells
c

      ncomp = CHF_NCOMP[array]

      CHF_DTERM[
      id = CHF_ID(0,dir)*side;
      jd = CHF_ID(1,dir)*side;
      kd = CHF_ID(2,dir)*side;
      ld = CHF_ID(3,dir)*side;
      md = CHF_ID(4,dir)*side;
      nd = CHF_ID(5,dir)*side
      ]

      CHF_MULTIDO[facebox; i; j; k; l; m; n]

        if (side .eq. -1) then
           CHF_DTERM[
           ni = id*(i-CHF_LBOUND[interiorbox;0])
           q = ni;
           nj = jd*(j-CHF_LBOUND[interiorbox;1])
           q = q + nj;
           nk = kd*(k-CHF_LBOUND[interiorbox;2])
           q = q + nk;
           nl = ld*(l-CHF_LBOUND[interiorbox;3])
           q = q + nl;
           nm = md*(m-CHF_LBOUND[interiorbox;4])
           q = q + nm;
           nn = nd*(n-CHF_LBOUND[interiorbox;5])
           q = q + nn
           ]
         else if (side .eq. 1) then
            CHF_DTERM[
            ni = id*(i-CHF_UBOUND[interiorbox;0])
            q = ni;
            nj = jd*(j-CHF_UBOUND[interiorbox;1])
            q = q + nj;
            nk = kd*(k-CHF_UBOUND[interiorbox;2])
            q = q + nk;
            nl = ld*(l-CHF_UBOUND[interiorbox;3])
            q = q + nl;
            nm = md*(m-CHF_UBOUND[interiorbox;4])
            q = q + nm;
            nn = nd*(n-CHF_UBOUND[interiorbox;5])
            q = q + nn
            ]
          endif

          do comp = 0, ncomp-1

             sum = zero
             if (order .eq. 4) then

                do p = 0, 4
                   sum = sum + coef4(p,q)*array(CHF_DDECL[i-id*(ni+p);j-jd*(nj+p);k-kd*(nk+p);l-ld*(nl+p);m-md*(nm+p);n-nd*(nn+p)],comp)
                enddo
                array(CHF_IX[i;j;k;l;m;n],comp) = sum

             else if (order .eq. 2) then

                do p = 0, 2
                   sum = sum + coef2(p,q)*array(CHF_DDECL[i-id*(ni+p);j-jd*(nj+p);k-kd*(nk+p);l-ld*(nl+p);m-md*(nm+p);n-nd*(nn+p)],comp)
                enddo
                array(CHF_IX[i;j;k;l;m;n],comp) = sum

             endif

          enddo

      CHF_ENDDO

      return
      end

      subroutine extrap_for_fc_ops(
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_INT[side],
     &     CHF_CONST_INT[order],
     &     CHF_BOX[facebox],
     &     CHF_BOX[interiorbox],
     &     CHF_FRA[array]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k;l;m;n]
      integer CHF_DDECL[id;jd;kd;ld;md;nd]
      integer CHF_DDECL[ni;nj;nk;nl;nm;nn]
      integer p, q, comp, ncomp
      double precision sum, coef2(0:2,2), coef4(0:4,2)
      data coef2 /  3.d0, -3.d0, 1.d0,
     &             6.d0, -8.d0, 3.d0 /
      data coef4 /  4.625d0, -8.5d0, 7.75d0, -3.5d0, 0.625d0,
     &             11.25d0, -25.d0, 22.5d0,  -9.d0, 1.25d0 /

c
c     If order = 2, this routine second-order extrapolates to at most two ghost cells
c     If order = 4, this routine fourth-order extrapolates to at most two ghost cells
c

      ncomp = CHF_NCOMP[array]

      CHF_DTERM[
      id = CHF_ID(0,dir)*side;
      jd = CHF_ID(1,dir)*side;
      kd = CHF_ID(2,dir)*side;
      ld = CHF_ID(3,dir)*side;
      md = CHF_ID(4,dir)*side;
      nd = CHF_ID(5,dir)*side
      ]

      CHF_MULTIDO[facebox; i; j; k; l; m; n]

        if (side .eq. -1) then
           CHF_DTERM[
           ni = id*(i-CHF_LBOUND[interiorbox;0])
           q = ni;
           nj = jd*(j-CHF_LBOUND[interiorbox;1])
           q = q + nj;
           nk = kd*(k-CHF_LBOUND[interiorbox;2])
           q = q + nk;
           nl = ld*(l-CHF_LBOUND[interiorbox;3])
           q = q + nl;
           nm = md*(m-CHF_LBOUND[interiorbox;4])
           q = q + nm;
           nn = nd*(n-CHF_LBOUND[interiorbox;5])
           q = q + nn
           ]
         else if (side .eq. 1) then
            CHF_DTERM[
            ni = id*(i-CHF_UBOUND[interiorbox;0])
            q = ni;
            nj = jd*(j-CHF_UBOUND[interiorbox;1])
            q = q + nj;
            nk = kd*(k-CHF_UBOUND[interiorbox;2])
            q = q + nk;
            nl = ld*(l-CHF_UBOUND[interiorbox;3])
            q = q + nl;
            nm = md*(m-CHF_UBOUND[interiorbox;4])
            q = q + nm;
            nn = nd*(n-CHF_UBOUND[interiorbox;5])
            q = q + nn
            ]
          endif

          do comp = 0, ncomp-1

             sum = zero
             if (order .eq. 4) then

                do p = 0, 4
                   sum = sum + coef4(p,q)*array(CHF_DDECL[i-id*(ni+p);j-jd*(nj+p);k-kd*(nk+p);l-ld*(nl+p);m-md*(nm+p);n-nd*(nn+p)],comp)
                enddo
                array(CHF_IX[i;j;k;l;m;n],comp) = sum

             else if (order .eq. 2) then

                do p = 0, 2
                   sum = sum + coef2(p,q)*array(CHF_DDECL[i-id*(ni+p);j-jd*(nj+p);k-kd*(nk+p);l-ld*(nl+p);m-md*(nm+p);n-nd*(nn+p)],comp)
                enddo
                array(CHF_IX[i;j;k;l;m;n],comp) = sum

             endif

          enddo

      CHF_ENDDO

      return
      end

      subroutine face_centered_grad_component(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_FRA1[var],
     &     CHF_CONST_REALVECT[h],
     &     CHF_CONST_INT[order],
     &     CHF_FRA1[grad]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k;l;m;n]
      integer CHF_DDECL[ii;jj;kk;ll;mm;nn]

      CHF_DTERM[
      ii = CHF_ID(0,dir);
      jj = CHF_ID(1,dir);
      kk = CHF_ID(2,dir);
      ll = CHF_ID(3,dir);
      mm = CHF_ID(4,dir);
      nn = CHF_ID(5,dir)]

      if (order .eq. 4) then

         CHF_MULTIDO[box; i; j; k; l; m; n]

            grad(CHF_IX[i;j;k;l;m;n]) = (
     &        27.d0 * (var(CHF_IX[i     ;j     ;k     ;l     ;m     ;n     ])
     &               - var(CHF_IX[i-  ii;j-  jj;k-  kk;l-  ll;m-  mm;n-  nn]))
     &               - var(CHF_IX[i+  ii;j+  jj;k+  kk;l+  ll;m+  mm;n+  nn])
     &               + var(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm;n-2*nn])
     &        ) / (24.d0 * h(dir))

         CHF_ENDDO

      else if (order .eq. 2) then

         CHF_MULTIDO[box; i; j; k; l; m; n]

            grad(CHF_IX[i;j;k;l;m;n]) = (
     &        - var(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm;n-nn])
     &        + var(CHF_IX[i   ;j   ;k   ;l   ;m   ;n   ])
     &        ) / h(dir)

         CHF_ENDDO

      endif

      return
      end

      subroutine cell_centered_grad_component(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_FRA1[var],
     &     CHF_CONST_REALVECT[h],
     &     CHF_CONST_INT[order],
     &     CHF_FRA1[grad]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k;l;m;n]
      integer CHF_DDECL[ii;jj;kk;ll;mm;nn]

      CHF_DTERM[
      ii = CHF_ID(0,dir);
      jj = CHF_ID(1,dir);
      kk = CHF_ID(2,dir);
      ll = CHF_ID(3,dir);
      mm = CHF_ID(4,dir);
      nn = CHF_ID(5,dir)]

      if (order .eq. 4) then

         CHF_MULTIDO[box; i; j; k; l; m; n]
      
            grad(CHF_IX[i;j;k;l;m;n]) = (
     &        var(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm;n-2*nn])
     &        - eight * var(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm;n-nn])
     &        + eight * var(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm;n+nn])
     &        - var(CHF_IX[i+2*ii;j+2*jj;k+2*kk;l+2*ll;m+2*mm;n+2*nn])
     &        ) / (twelve * h(dir))

         CHF_ENDDO

      else if (order .eq. 2) then

         CHF_MULTIDO[box; i; j; k; l; m; n]

            grad(CHF_IX[i;j;k;l;m;n]) = (
     &        - var(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm;n-nn])
     &        + var(CHF_IX[i+ii;j+jj;k+kk;l+ll;m+mm;n+nn])
     &        ) / (two * h(dir))
          
         CHF_ENDDO

      endif

      return
      end

      subroutine face_interpolate(
     &     CHF_CONST_INT[dir],
     &     CHF_BOX[box],
     &     CHF_CONST_INT[order],
     &     CHF_CONST_FRA1[var],
     &     CHF_FRA1[face_var]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k;l;m;n]
      integer CHF_DDECL[ii;jj;kk;ll;mm;nn]

      CHF_DTERM[
      ii = CHF_ID(0,dir);
      jj = CHF_ID(1,dir);
      kk = CHF_ID(2,dir);
      ll = CHF_ID(3,dir);
      mm = CHF_ID(4,dir);
      nn = CHF_ID(5,dir)]

      if (order .eq. 4) then

         CHF_MULTIDO[box;i;j;k;l;m;n]

            face_var(CHF_IX[i;j;k;l;m;n]) = (
     &        9.d0 * (var(CHF_IX[i     ;j     ;k     ;l     ;m     ;n     ])
     &              + var(CHF_IX[i-  ii;j-  jj;k-  kk;l-  ll;m-  mm;n-  nn]))
     &             - (var(CHF_IX[i+  ii;j+  jj;k+  kk;l+  ll;m+  mm;n+  nn])
     &              + var(CHF_IX[i-2*ii;j-2*jj;k-2*kk;l-2*ll;m-2*mm;n-2*nn]))
     &        ) / 16.d0

         CHF_ENDDO

      else if (order .eq. 2) then

         CHF_MULTIDO[box;i;j;k;l;m;n]

         face_var(CHF_IX[i;j;k;l;m;n]) = (
     &            var(CHF_IX[i-ii;j-jj;k-kk;l-ll;m-mm;n-nn])
     &          + var(CHF_IX[i   ;j   ;k   ;l   ;m   ;n   ])
     &        ) / 2.d0

         CHF_ENDDO

      endif

      return
      end

      subroutine second_order_extrapolation(
     &     CHF_CONST_INT[dir],
     &     CHF_CONST_INT[side],
     &     CHF_BOX[srcbox],
     &     CHF_BOX[dstbox],
     &     CHF_FRA[array]
     &     )

c     local variables
      double precision coef(0:2), sum
      data coef / 3.d0, -3.d0, 1.d0 /
      integer CHF_DDECL[i,id,ni;j,jd,nj;k,kd,nk;l,ld,nl;m,md,nm;n,nd,nn], p, comp, ncomp

c     to avoid  "may be uninitialized warnings"
      CHF_DTERM[
      ni = 0;
      nj = 0;
      nk = 0;
      nl = 0;
      nm = 0;
      nn = 0;
      ]

      ncomp = CHF_NCOMP[array]

      CHF_DTERM[
      id = CHF_ID(0,dir)*side;
      jd = CHF_ID(1,dir)*side;
      kd = CHF_ID(2,dir)*side;
      ld = CHF_ID(3,dir)*side;
      md = CHF_ID(4,dir)*side;
      nd = CHF_ID(5,dir)*side
      ]

      CHF_MULTIDO[dstbox; i;j;k;l;m;n]

        if (side .eq. -1) then
           CHF_DTERM[
           ni = id*(i-CHF_LBOUND[srcbox;0]);
           nj = jd*(j-CHF_LBOUND[srcbox;1]);
           nk = kd*(k-CHF_LBOUND[srcbox;2]);
           nl = ld*(l-CHF_LBOUND[srcbox;3]);
           nm = md*(m-CHF_LBOUND[srcbox;4]);
           nn = nd*(n-CHF_LBOUND[srcbox;5])
           ]
        else if (side .eq. 1) then
           CHF_DTERM[
           ni = id*(i-CHF_UBOUND[srcbox;0]);
           nj = jd*(j-CHF_UBOUND[srcbox;1]);
           nk = kd*(k-CHF_UBOUND[srcbox;2]);
           nl = ld*(l-CHF_UBOUND[srcbox;3]);
           nm = md*(m-CHF_UBOUND[srcbox;4]);
           nn = nd*(n-CHF_UBOUND[srcbox;5])
            ]
          endif

          do comp = 0, ncomp-1
             sum = 0.d0
             do p = 0, 2
                sum = sum + coef(p)*
     &               array(CHF_DDECL[i-id*(ni+p);j-jd*(nj+p);k-kd*(nk+p);l-ld*(nl+p);m-md*(nm+p);n-nd*(nn+p)],comp)
             enddo
             array(CHF_IX[i;j;k;l;m;n],comp) = sum
          enddo

      CHF_ENDDO

      return
      end

      subroutine copy(
     &     CHF_BOX[gridbox],
     &     CHF_FRA[dst],
     &     CHF_CONST_FRA[src]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k;l;m;n], comp

      CHF_MULTIDO[gridbox;i;j;k;l;m;n]

         do comp = 0, CHF_NCOMP[dst]-1

           dst(CHF_IX[i;j;k;l;m;n],comp) = src(CHF_IX[i;j;k;l;m;n],comp)

         enddo

      CHF_ENDDO

      return
      end
     
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      subroutine vector_norm(
     &     CHF_BOX[gridbox],
     &     CHF_FRA1[dst],
     &     CHF_CONST_FRA[src]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k;l;m;n], comp
      double precision val

      CHF_MULTIDO[gridbox;i;j;k;l;m;n]

         val = 0.0
         do comp = 0, CHF_NCOMP[src]-1

           val = val + src(CHF_IX[i;j;k;l;m;n],comp)*src(CHF_IX[i;j;k;l;m;n],comp)

         enddo
         dst(CHF_IX[i;j;k;l;m;n]) = sqrt(val)

      CHF_ENDDO

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    EASY WAY TO LOOK AT WHAT IS IN FARRAYBOX

      subroutine inspect_farraybox(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA1[FA0],
     &     )

c     local variables
      integer CHF_AUTODECL[i]
      double precision F00

      CHF_AUTOMULTIDO[gridbox;i]

        F00  = FA0(CHF_AUTOIX[i]) 
c        print*, "shape(F0)   = ", shape(F0)
        print*, "CHF_AUTOIX[i]    = ", CHF_AUTOIX[i]
        print*, "F00    = ", F00

      CHF_ENDDO

      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c    EASY WAY TO LOOK AT WHAT IS IN FLUXBOX / EDGEBOX

      subroutine inspect_fluxbox(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_FRA[Flux],
     &     CHF_CONST_INT[dir]
     &     )

c     local variables
      integer n, CHF_AUTODECL[i]
      integer CHF_DDECL[ii;jj;kk;ll;mm]
      double precision F00, F01, F10, F11, F2, F3
      integer n0, n1
c      integer, dimension (3) :: shapeF

      CHF_DTERM[
      ii = CHF_ID(dir, 0);
      jj = CHF_ID(dir, 1);
      kk = CHF_ID(dir, 2);
      ll = CHF_ID(dir, 3);
      mm = CHF_ID(dir, 4)]

c      shapeF = shape(Flux)
c      print*, "shape(Flux)  = ", shapeF

      do n=0, (CHF_NCOMP[Flux]-1)
        print*, "component    = ", n
c         do j=0, (shapeF(2)-1) 
c            do i=0, (shapeF(1)-1)

      CHF_AUTOMULTIDO[gridbox;i]

c        print*, "component    = ", n
c        shapeF = reshape(shapeF,shape(Flux))
c        print*, "shapeF(dir+1)  = ", shapeF(dir+1)
        print*, "CHF_AUTOIX[i]  = ", CHF_AUTOIX[i]
        print*, "Flux    = ", Flux(CHF_AUTOIX[i],n)
c        print*, "Flux    = ", Flux(CHF_IX[ii;jj;kk],n)

      CHF_ENDDO
c            enddo
c         enddo
      enddo
  
      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc



