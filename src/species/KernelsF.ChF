#include "CONSTANTS.H"

      subroutine compute_vel_cell(
     &     CHF_FRA[velCell],
     &     CHF_FRA[velFace],
     &     CHF_CONST_INT[dir],
     &     CHF_BOX[gridbox]
     &     )

c     local variables
      integer CHF_DDECL[i;j;k;l], CHF_DDECL[ii;jj;kk;ll]

      CHF_DTERM[
      ii = CHF_ID(0,dir);
      jj = CHF_ID(1,dir);
      kk = CHF_ID(2,dir);
      ll = CHF_ID(3,dir)]

      CHF_MULTIDO[gridbox;i;j;k;l]

         velCell(CHF_IX[i;j;k;l],dir) = 0.5 * (velFace(CHF_IX[i;j;k;l],dir)
     &                                + velFace(CHF_IX[i+ ii;j+ jj;k+ kk;l+ ll],dir)) 
             
      CHF_ENDDO

      return
      end


      subroutine get_pol_momentum(
     &     CHF_BOX[gridbox],
     &     CHF_CONST_REALVECT[dv],
     &     CHF_CONST_REALVECT[dx],
     &     CHF_FRA1[kern],
     &     CHF_CONST_FRA1[f],
     &     CHF_FRA[vel],
     &     CHF_CONST_FRA1[Bmagn],
     &     CHF_CONST_FRA[Bvect],
     &     CHF_CONST_FRA[curlb],
     &     CHF_CONST_FRA1[gradFFac],
     &     CHF_CONST_REAL[larmor],
     &     CHF_CONST_REAL[charge]
     &     )

c     local variables
      double precision curlbpol, btor, dfdr, VgcPol, rotM 
      integer CHF_DDECL[i;j;k;l]

      CHF_MULTIDO[gridbox;i;j;k;l]

c     ***Obtain b_tor (Bfield components in the physical frame are: R-0, phi-1, Z-2)
         btor = Bvect(i,j,CHF_LBOUND[Bvect;2],CHF_LBOUND[Bvect;3],1)  
     &          /Bmagn(i,j,CHF_LBOUND[Bmagn;2],CHF_LBOUND[Bmagn;3])

         curlbpol=curlb(i,j,CHF_LBOUND[Bvect;2],CHF_LBOUND[Bvect;3],1) 

c     ***Calculate df/dr
         dfdr = (f(i+1,j,k,l)-f(i-1,j,k,l))/(2.0*dx(0))
     &         * gradFFac(i,j,k,l)  

c     ***Calculate the poloidal projection of the guiding center velocity
         VgcPol = vel(CHF_IX[i;j;k;l],1) * f(i,j,k,l) 

c     ***Calclate the rotM (rotor of the magnetization)      
         rotM = - curlbpol * f(i,j,k,l) * (l+0.5)*dv(1) - btor * dfdr * (l+0.5)*dv(1) 

c     ***Calculate the kernel for total poloidal flow velocity (n*Vpol) 
         kern(i,j,k,l) = VgcPol + (larmor/2) * rotM / charge 

      CHF_ENDDO
      
      return
      end

