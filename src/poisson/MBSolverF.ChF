      subroutine accum_flux_stencil4(
     &     CHF_CONST_INT[s],
     &     CHF_CONST_INT[sprime],
     &     CHF_CONST_INT[side],
     &     CHF_CONST_REALVECT[h],
     &     CHF_CONST_FRA1[Dtilde_av],
     &     CHF_CONST_INTVECT[global],
     &     CHF_CONST_INT[drop_order],
     &     CHF_FRA1[sum]
     &     )

      integer
     &     CHF_DDECL[i;j], CHF_DDECL[ii;jj], CHF_DDECL[it;jt], CHF_DDECL[ic;jc],
     &     CHF_DDECL[lo0;lo1], CHF_DDECL[hi0;hi1], CHF_DDECL[iglobal;jglobal],
     &     dir, tdir, m, m_max, n, noffset, nlength, toffset
      REAL_T hfac, n_stencil(0:3), gamma4(0:4), gamma2(0:4),
     &     gamma4_lo(0:4), gamma4_hi(0:4), gamma2_lo(0:4), gamma2_hi(0:4),
     &     d, trans_grad_d, flux(0:4), trans_grad_flux(0:4)

      dir = s
      iglobal = global(0)
      jglobal = global(1)

      CHF_DTERM[
      ii = CHF_ID(0,dir);
      jj = CHF_ID(1,dir)]

      CHF_DTERM[
      it = 1 - ii;
      jt = 1 - jj]

      if (drop_order .eq. 0) then
         ic = 3
         jc = 3
      else
         ic = 2
         jc = 2
      endif

      tdir = 1 - dir

c     Get normal direction stencil factors

      noffset = side - 2
      nlength = 4

      if (s .eq. sprime) then

c        fourth-order accurate first derivative (Eq. (30))
         n_stencil(0) =   1.d0 / 24.d0
         n_stencil(1) = -27.d0 / 24.d0
         n_stencil(2) =  27.d0 / 24.d0
         n_stencil(3) =  -1.d0 / 24.d0

      else

c        fourth-order accurate interpolation (Eq. (35))
         n_stencil(0) = -1.d0 / 16.d0
         n_stencil(1) =  9.d0 / 16.d0
         n_stencil(2) =  9.d0 / 16.d0
         n_stencil(3) = -1.d0 / 16.d0

      endif

c     Get transverse direction stencil factors

      m_max = 4
      toffset = -2

      if (s .eq. sprime) then

c        exact function evaluations
         gamma4_lo(0) = 0.d0
         gamma4_lo(1) = 1.d0
         gamma4_lo(2) = 0.d0
         gamma4_lo(3) = 0.d0
         gamma4_lo(4) = 0.d0

         gamma4(0) = 0.d0
         gamma4(1) = 0.d0
         gamma4(2) = 1.d0
         gamma4(3) = 0.d0
         gamma4(4) = 0.d0

         gamma4_hi(0) = 0.d0
         gamma4_hi(1) = 0.d0
         gamma4_hi(2) = 0.d0
         gamma4_hi(3) = 1.d0
         gamma4_hi(4) = 0.d0

c        second-order accurate second derivative

         gamma2(0) =  0.d0
         gamma2(1) =  1.d0
         gamma2(2) = -2.d0
         gamma2(3) =  1.d0
         gamma2(4) =  0.d0

      else

c        fourth-order accurate first derivative

c        Eq. (32) with the minus
         gamma4_lo(0) =  -3.d0 / 12.d0
         gamma4_lo(1) = -10.d0 / 12.d0
         gamma4_lo(2) =  18.d0 / 12.d0
         gamma4_lo(3) =  -6.d0 / 12.d0
         gamma4_lo(4) =   1.d0 / 12.d0

c        Eq. (27)
         gamma4(0)     =  1.d0 / 12.d0
         gamma4(1)     = -8.d0 / 12.d0
         gamma4(2)     =  0.d0
         gamma4(3)     =  8.d0 / 12.d0
         gamma4(4)     = -1.d0 / 12.d0

c        Eq. (32) with the plus
         gamma4_hi(0) =  -1.d0 / 12.d0
         gamma4_hi(1) =   6.d0 / 12.d0
         gamma4_hi(2) = -18.d0 / 12.d0
         gamma4_hi(3) =  10.d0 / 12.d0
         gamma4_hi(4) =   3.d0 / 12.d0

c        second-order accurate third derivative (Eq. (28))

         gamma2(0)      = -1.d0 / 2.d0
         gamma2(1)      =  2.d0 / 2.d0
         gamma2(2)      =  0.d0
         gamma2(3)      = -2.d0 / 2.d0
         gamma2(4)      =  1.d0 / 2.d0

      endif

      do m = 0, m_max
         flux(m) = gamma4(m) + gamma2(m) / 24.d0
         trans_grad_flux(m) = 0.5d0 * (gamma4_hi(m) - gamma4_lo(m))
      enddo

      trans_grad_d = 0.5d0 * (
     &     Dtilde_av(iglobal+ii*side+it,jglobal+jj*side+jt)
     &     -  Dtilde_av(iglobal+ii*side-it,jglobal+jj*side-jt)
     &     )
      
c     Accumulate the stencil contributions

      if (dir .eq. 0) then
         lo0 = ic + noffset
         hi0 = lo0 + nlength - 1
         lo1 = jc + toffset - 1
         hi1 = lo1
      else
         lo0 = ic + toffset - 1
         hi0 = lo0
         lo1 = jc + noffset
         hi1 = lo1 + nlength - 1
      endif

      hfac = dble(1 - 2*side)
      if (s .eq. sprime) then
         hfac = hfac * h(tdir) / h(dir)
      endif

      d = Dtilde_av(iglobal+side*ii,jglobal+side*jj)

      do m = 0, m_max
         lo1 = lo1 + ii
         hi1 = hi1 + ii
         lo0 = lo0 + jj
         hi0 = hi0 + jj

         n = -1
         do j = lo1, hi1
            do i = lo0, hi0
               n = n + 1
               sum(CHF_IX[i;j]) = sum(CHF_IX[i;j]) + hfac * n_stencil(n) *
     &                           (d * flux(m) + trans_grad_d * trans_grad_flux(m) / 12.d0)
            enddo
         enddo
      enddo

      return
      end


      subroutine accum_flux_stencil2(
     &     CHF_CONST_INT[s],
     &     CHF_CONST_INT[sprime],
     &     CHF_CONST_INT[side],
     &     CHF_CONST_REALVECT[h],
     &     CHF_CONST_FRA1[Dtilde_av],
     &     CHF_CONST_INTVECT[global],
     &     CHF_FRA1[sum]
     &     )
      integer
     &     CHF_DDECL[i;j], CHF_DDECL[ii;jj], CHF_DDECL[ic;jc],
     &     CHF_DDECL[lo0;lo1], CHF_DDECL[hi0;hi1],  CHF_DDECL[iglobal;jglobal],
     &     dir, tdir, m, m_max, n, noffset, toffset, nlength
      REAL_T hfac, n_stencil(0:1), t_stencil(0:2), norm_fac

      dir = s
      iglobal = global(0)
      jglobal = global(1)

      CHF_DTERM[
      ic = 1;
      jc = 1]

      CHF_DTERM[
      ii = CHF_ID(0,dir);
      jj = CHF_ID(1,dir)]
      tdir = 1 - dir

      hfac = (1 - 2*side) * Dtilde_av(iglobal+side*ii,jglobal+side*jj)

      if (s. eq. sprime) then
         hfac = hfac * h(tdir) / h(dir)
      endif

      if (s. eq. sprime) then

         noffset = side - 1
         nlength = 2
         m_max   = 0
         toffset = 0

         n_stencil(0) = -1.d0
         n_stencil(1) =  1.d0
         t_stencil(0) =  1.d0

      else

         n_stencil(0) = 0.5d0
         n_stencil(1) = 0.5d0
         
         noffset = side - 1
         nlength = 2

         m_max   = 2
         toffset = -1

         t_stencil(0) = -1.d0 / 2.d0
         t_stencil(1) =  0.d0
         t_stencil(2) =  1.d0 / 2.d0
         
      endif

c     Accumulate the stencil contributions

      if (dir .eq. 0) then
         lo0 = ic + noffset
         hi0 = lo0 + nlength - 1
         lo1 = jc + toffset - 1
         hi1 = lo1
      else
         lo0 = ic + toffset - 1
         hi0 = lo0
         lo1 = jc + noffset
         hi1 = lo1 + nlength - 1
      endif

      do m = 0, m_max
         if (dir .eq. 0) then
            lo1 = lo1 + 1
            hi1 = hi1 + 1
         else
            lo0 = lo0 + 1
            hi0 = hi0 + 1
         endif

         n = -1
         do j = lo1, hi1
            do i = lo0, hi0
               n = n + 1
               sum(CHF_IX[i;j]) = sum(CHF_IX[i;j]) + hfac * n_stencil(n) * t_stencil(m)
            enddo
         enddo
      enddo

      return
      end
